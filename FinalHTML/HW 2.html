
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Finance 937 - Problem Set 2</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-11-03"><meta name="DC.source" content="Untitled2.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Finance 937 - Problem Set 2</h1><!--introduction--><p>Shasha Wang, Rodrigo Morales Mendoza, Pawel Bednarek</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Part I: Liquidity/Covenant Default</a></li><li><a href="#4">a) Probability of Default Next Period</a></li><li><a href="#6">b) Required Rate of Return of Bonds</a></li><li><a href="#8">c) Value Function Iteration</a></li><li><a href="#9">d) Stationary Distribution of Firms</a></li><li><a href="#29">Part II: Method of Simulated Moments</a></li><li><a href="#36">Part III: Optimal Default</a></li><li><a href="#42">a) Value Function Iteration when Rb = 1.01Rf</a></li><li><a href="#53">b) Probability of Default Next Period</a></li><li><a href="#54">c) Required Rate of Return of Bonds</a></li><li><a href="#55">d) Value Function Iteration given Rb = mRb(k',b',z).</a></li></ul></div><h2 id="1">Part I: Liquidity/Covenant Default</h2><p>Housekeeping</p><pre class="codeinput">clear;
close <span class="string">all</span>;
</pre><p>Parametization.</p><pre class="codeinput">M = 0.99;
Rf = 1/M;
r = 1/M-1; <span class="comment">% interest rate for notation convenience</span>
ddelta = 0.1;
aalphaK = 0.3;
aalphaL = 0.6;
W = 2; <span class="comment">% wage</span>
llambda = 0.025; <span class="comment">% proportional cost of issuing equity</span>
ttaoC=0.15; <span class="comment">% corporate tax rate</span>
</pre><p>k_grid, b_grid, a_grid, m_a_prob and a's transition probability matrix.</p><pre class="codeinput">Nk = 20;
kMin = 0.00001;

kSteadyState = 1;
tempK = kSteadyState^((aalphaK+aalphaL-1)/(1-aalphaL));
aMean = ((r+ddelta)/aalphaK/tempK)^(1-aalphaL)*(W/aalphaL)^aalphaL; <span class="comment">% set a such that k_SteadyState equals how much you set it to be;</span>

<span class="comment">% a_grid and a's transition matrix</span>
m = 3; <span class="comment">% parameter for tauchen method</span>
Na = 3;
rrho = 0.7;
ssigma = 0.05;
[grid_a_log,m_a_prob] = tauchen(Na,log(aMean),rrho,ssigma,m);
grid_a = exp(grid_a_log)';
grid_a_minus = grid_a;
aMax = max(grid_a);

<span class="comment">% k_grid</span>
kMax = (aMax/ddelta)^(1/(1-aalphaK));
kMax = min(2*kSteadyState, kMax); <span class="comment">% Tighten the grid</span>
grid_k = curvspace(kMin,kMax,Nk,2)'; <span class="comment">% I use curved grid to enhance accuracy</span>

<span class="comment">% b_grid grid for bond</span>
<span class="comment">% b_grid should be finer to see the difference in default probability under different productivity shocks at steady state</span>
Nb = 15;
grid_b = curvspace(0,kMax,Nb,2)'; <span class="comment">% To cover up as wide leverage level as possible</span>

<span class="comment">% invariant distribution of a_grid - vDistribution_a0</span>
vDistribution_a0=( 1/Na )*ones(Na,1); <span class="comment">% initial guess</span>
vDistribution_a=vDistribution_a0;
distance=100; tolerance=0.00001;
iteration = 0;
<span class="keyword">while</span> distance&gt;tolerance
    distribution = vDistribution_a'*m_a_prob;
    distance=sum(abs(distribution-vDistribution_a'));
    vDistribution_a = distribution';
    iteration = iteration+1;
<span class="keyword">end</span>

clear <span class="string">vDistribution_a0</span> <span class="string">distribution</span>;
</pre><h2 id="4">a) Probability of Default Next Period</h2><p>Compute and plot the probability of default next period, conditional on the value of the shocks today p(z,b',k').</p><p>Also, rewrite profit = a^(1/(1-aalphaL)) * (k.^aalphaK .* (aalphaL * k.^aalphaK / W).^(aalphaL/(1-aalphaL)) - W * (aalphaL * k.^aalphaK/W).^(1/(1-aalphaL))); once we plug in the FOC for labor.</p><pre class="codeinput">mCutOffValue = zeros(Nk,Nb);
mDefaultProbability = zeros(Nk,Nb,Na);

vDenominator = grid_k.^aalphaK .* (aalphaL * grid_k.^aalphaK / W).^(aalphaL/(1-aalphaL)) - W * (aalphaL * grid_k.^aalphaK/W).^(1/(1-aalphaL));

<span class="keyword">for</span> ib = 1:Nb
    vNumerator =  (grid_b(ib) - (1-ddelta)*grid_k)/(1-ttaoC);
<span class="comment">%     vCutOffValue = (vNumerator ./v_Denominator).^(1-aalphaL); % I droped</span>
<span class="comment">%     this line because it generates complex numbers</span>
    vCutOffValue = vNumerator ./vDenominator;
    mCutOffValue(:,ib) = vCutOffValue; <span class="comment">% cutoff value^(1-aalphaL) is cutoff productivity, but I don't use productivity per se in order to avoid complex numbers</span>
    <span class="keyword">for</span> ia = 1:Na
        <span class="keyword">for</span> ik = 1:Nk
             temp= (vCutOffValue(ik) &gt; grid_a.^(1/(1-aalphaL)));
            mDefaultProbability(ik,ib,ia) = sum(temp.* m_a_prob(ia,:)');
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% plot the 3D matrix layer by layer</span>
figure(1);
[bb,kk]=meshgrid(grid_b, grid_k);
mesh(bb, kk, mDefaultProbability(:,:,1));

<span class="keyword">for</span> ia = 2:Na
    hold <span class="string">on</span>;
    mesh(bb, kk, mDefaultProbability(:,:,ia));
<span class="keyword">end</span>

title(<span class="string">'Next Period Default Probability'</span>)
ylabel(<span class="string">'Next Period Capital Stock $k^\prime$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
xlabel(<span class="string">'Next Period Debt $b^\prime$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
zlabel(<span class="string">'Next Period Default Probability'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
zlim([0,1])
savefig(<span class="string">'q1a_default_prob_3D'</span>)

<span class="comment">% plot a 2D default risk graph in steady state k=1</span>
<span class="comment">% we cannot tell from the graph differences among different productivity</span>
<span class="comment">% situations</span>
figure(2)
[v,ind] = max(-abs(grid_k - kSteadyState));
plot(grid_b,mDefaultProbability(ind,:,1));
<span class="keyword">for</span> ia=2:Na
    hold <span class="string">on</span>
    plot(grid_b,mDefaultProbability(ind,:,ia));
<span class="keyword">end</span>
ylim([0,1]);
legend(<span class="string">'low productivity'</span>,<span class="string">'median productivity'</span>,<span class="string">'high productivity'</span>,<span class="string">'Location'</span>,<span class="string">'southeast'</span>)
title(<span class="string">'Default Probability at Steady State $p(z,k^\prime,b^\prime)$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
xlabel(<span class="string">'Next Period Debt $b^\prime$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylabel(<span class="string">'Next Period Default Probability'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
savefig(<span class="string">'q1a_default_prob_2D'</span>)
</pre><img vspace="5" hspace="5" src="HW2_01.png" alt=""> <img vspace="5" hspace="5" src="HW2_02.png" alt=""> <h2 id="6">b) Required Rate of Return of Bonds</h2><p>Use the conditional default probability to compute the required rate of return by bondholders, Rb(b'; k'; z) that ensures they make 0 profits. Assume for simplicity bondholders get paid 0 upon default.</p><pre class="codeinput">mRf = Rf*ones(Nk,Nb,Na);
mCarryOnProbability = 1-mDefaultProbability;
mIsDefaultNextPeriod = (mDefaultProbability==1);

mRb = min(Rf/mCarryOnProbability,1000000);
</pre><p>Functions We create some functions for future convenience.</p><pre class="codeinput">profitFunction = @(a,k)a.* k.^aalphaK.* ((k.^aalphaK * aalphaL).* a/W).^(aalphaL/(1-aalphaL)) - W * ((k.^aalphaK * aalphaL).* a/W).^(1/(1-aalphaL));
nonDefaultFunction = @ (profit,k,bond)((1-ttaoC)*profit + (1-ddelta)*k &gt; bond);
isDefaultNextPeriod2DFunction = @(ia,mIsDefaultNextPeriod3D)(mIsDefaultNextPeriod3D(:,:,ia));
investmentFunction = @(k,kPrime,mIsDefaultNextPeriod)kPrime.*(1-mIsDefaultNextPeriod) - (1-ddelta)*k; <span class="comment">%k_prime usually is k_grid</span>
taxPaymentsFunction = @(k,bond,profit,RbMinus)ttaoC * (profit - ddelta*k - bond.* (RbMinus-1).* ((1-ttaoC)*profit + (1-ddelta)*k &gt; bond)); <span class="comment">% note the non-default indicator</span>
dividentFunction = @(profit,investment,bond,bondPrime,RbMinus,taxPayments,mIsDefaultNextPeriod)(profit - investment  <span class="keyword">...</span>
    + bondPrime.*(1-mIsDefaultNextPeriod) - RbMinus.* bond - taxPayments).*(1 + llambda * ((profit - investment  <span class="keyword">...</span>
    + bondPrime.*(1-mIsDefaultNextPeriod) - RbMinus.* bond - taxPayments) &lt; 0)); <span class="comment">% note the indicator function for issuance cost</span>
</pre><h2 id="8">c) Value Function Iteration</h2><p>Solve the Bellman equation for the equity holders taking as given the function for the required rate of return by bondholders, Rb</p><pre class="codeinput"><span class="comment">% Use multigrid method to speed up iteration</span>
kGridLength           = [15]; <span class="comment">% number of points in grid for capital</span>
kMin            = 0.000001;
kMax            = 10 * kSteadyState;
grid_b = curvspace(0,kMax,Nb,2)';

<span class="comment">% Required matrices and vectors</span>
<span class="comment">% Dimensionality is k,b,a,aMinus</span>

kPolicyIndex = zeros(kGridLength(1),Nb,Na,Na);
kPolicy = zeros(kGridLength(1),Nb,Na,Na);
bPolicyIndex = zeros(kGridLength(1),Nb,Na,Na);
bPolicy = zeros(kGridLength(1),Nb,Na,Na);

value   = zeros(kGridLength(1),Nb,Na,Na);
value0 = ones(kGridLength(1),Nb,Na,Na); <span class="comment">% initial guess</span>

tic
<span class="keyword">for</span> i=1:length(kGridLength)

    grid_k = curvspace(kMin,kMax,kGridLength(i),2)';
    <span class="comment">% Since the profitFunction takes so much time, let's calculate it all</span>
    <span class="comment">% at once to retrieve later</span>
    mANkByNa = repmat(grid_a',kGridLength(i),1);
    mKNkByNa = repmat(grid_k,1,Na);
    profitNkByNa = profitFunction(mANkByNa,mKNkByNa); <span class="comment">% Nk by Na</span>

    <span class="comment">% Calculate Default Probability</span>
    mCutOffValue = zeros(kGridLength(i),Nb);
    mDefaultProbability = zeros(kGridLength(i),Nb,Na);

    vDenominator = grid_k.^aalphaK .* (aalphaL * grid_k.^aalphaK / W).^(aalphaL/(1-aalphaL)) - W * (aalphaL * grid_k.^aalphaK/W).^(1/(1-aalphaL));

    <span class="keyword">for</span> ib = 1:Nb
        vNumerator =  (grid_b(ib) - (1-ddelta)*grid_k)/(1-ttaoC);

        vCutOffValue = vNumerator ./vDenominator;
        mCutOffValue(:,ib) = vCutOffValue; <span class="comment">% cutoff value^(1-aalphaL) is cutoff productivity, but I don't use productivity per se in order to avoid complex numbers</span>
        <span class="keyword">for</span> ia = 1:Na
            <span class="keyword">for</span> ik = 1:kGridLength(1)
                 temp= (vCutOffValue(ik) &gt; grid_a.^(1/(1-aalphaL)));
                mDefaultProbability(ik,ib,ia) = sum(temp.* m_a_prob(ia,:)');
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    mRf = Rf*ones(kGridLength(1),Nb,Na);
    mIsDefaultNextPeriod = (mDefaultProbability==1);
    mCarryOnProbability = 1-mDefaultProbability;
    mRb = min(Rf/mCarryOnProbability,1000000);

    tolerance = 0.00001;
    iteration = 0;
    distance = 100;

    kPrime = repmat(grid_k,1,Nb); <span class="comment">% Nk*Nb matrix</span>
    bondPrime = repmat(grid_b',kGridLength(i),1); <span class="comment">% Nk*Nb matrix</span>

    tic
    <span class="keyword">while</span> distance &gt; tolerance
        <span class="keyword">for</span> ia=1:Na
            a = grid_a(ia);
            isDefaultNextPeriod = mIsDefaultNextPeriod(:,:,ia);
            <span class="keyword">for</span> ik=1:kGridLength(i)
                k = grid_k(ik);
                profit = profitNkByNa(ik,ia);<span class="comment">% scalar</span>
                investment = investmentFunction(k,kPrime,isDefaultNextPeriod); <span class="comment">% Nk*Nb matrix</span>
                <span class="keyword">for</span> iaMinus = 1:Na
                    RbMinus = mRb(:,:,iaMinus); <span class="comment">% Nk*Nb matrix</span>
                    aMinus = grid_a(iaMinus);
                    <span class="keyword">for</span> ib = 1:Nb
                        bond = grid_b(ib);
                        <span class="keyword">if</span> (1-ttaoC)*profit + (1-ddelta)*k &lt;= bond
                            value (ik,ib,ia,iaMinus)=0; <span class="comment">% You stop operating the firm and stop choosing next period k' and b'</span>
                        <span class="keyword">else</span>
                            taxPayments = taxPaymentsFunction(k,bond,profit,RbMinus); <span class="comment">% Nk*Nb matrix</span>
                            divident = dividentFunction(profit,investment,bond,bondPrime,RbMinus,taxPayments,isDefaultNextPeriod); <span class="comment">% Nk*Nb matrix</span>
                            valueTomorrow = zeros(kGridLength(i),Nb,Na); <span class="comment">% k',b',a'</span>

                            <span class="keyword">for</span> iaPrime = 1:Na <span class="comment">% iterate over all possible states for tomorrow</span>
                                aPrime = grid_a(iaPrime);
                                profitPrime = repmat(profitNkByNa(:,iaPrime),1,Nb);<span class="comment">% Nk*Nb</span>
                                valueTomorrow(:,:,iaPrime) = value0(:,:,iaPrime,ia) * m_a_prob(ia,iaPrime) .* ((1-ttaoC)*profitPrime + (1-ddelta)*kPrime &gt; bondPrime);<span class="comment">% &ETH;&egrave;&Ograve;&ordf;&iquest;&frac14;&Acirc;&Ccedil;default&Ouml;&reg;&ordm;&oacute;value&Icirc;&ordf;0</span>
                            <span class="keyword">end</span>
                            valueTomorrow = sum(valueTomorrow,3); <span class="comment">% sum by the third dimension to get a Nk*Nb matrix</span>
                            x = divident + M * valueTomorrow;
                            [rows,cols]=find(x==max(max(x)));
                            kPolicyIndex(ik,ib,ia,iaMinus) = min(rows);
                            bPolicyIndex(ik,ib,ia,iaMinus) = min(cols);
                            kPolicy(ik,ib,ia,iaMinus) = grid_k(min(rows));
                            bPolicy(ik,ib,ia,iaMinus) = grid_b(min(cols));
                            value(ik,ib,ia,iaMinus) = max(max(x));
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        distance = sum(sum(sum(sum(abs(value(:,:,:,:)-value0(:,:,:,:))))));
        value0 = value;
        iteration = iteration + 1;
        <span class="comment">%if mod(iteration,5) == 0</span>
        <span class="comment">%    display("iteration =    " + iteration + "   difference =   " + distance )</span>
        <span class="comment">%end</span>
    <span class="keyword">end</span>
    display(<span class="string">"iteration =    "</span> + iteration + <span class="string">"   difference =   "</span> + distance + <span class="string">". Converged"</span>)
    <span class="keyword">if</span> i ~= length(kGridLength)
        value0 = interp1(grid_k,value,linspace(kMin, kMax, kGridLength(i+1)));
        value  = value0;
        kPolicy         = zeros(kGridLength(i+1),Nb,Na,Na);
        kPolicyIndex    = zeros(kGridLength(i+1),Nb,Na,Na);
        bPolicy         = zeros(kGridLength(i+1),Nb,Na,Na);
        bPolicyIndex    = zeros(kGridLength(i+1),Nb,Na,Na);
    <span class="keyword">end</span>
<span class="keyword">end</span>

toc
save(<span class="string">'valuePrevious'</span>,<span class="string">'value'</span>)
save(<span class="string">'resultC'</span>,<span class="string">'value'</span>,<span class="string">'kPolicy'</span>,<span class="string">'bPolicy'</span>,<span class="string">'kPolicyIndex'</span>,<span class="string">'bPolicyIndex'</span>)

figure(3);
[bb,kk]=meshgrid(grid_b, grid_k);
mesh(bb, kk, value(:,:,1,round((Na+1)/2)));<span class="comment">% yesterday's productivity is mean</span>

<span class="keyword">for</span> ia = 2:Na
    hold <span class="string">on</span>;
    mesh(bb, kk, value(:,:,ia,round((Na+1)/2)));
<span class="keyword">end</span>

title(<span class="string">'Value Under Different Shocks given mean $z^{-}$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylabel(<span class="string">'Capital Stock $k$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
xlabel(<span class="string">'Debt $b$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
zlabel(<span class="string">'Value'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
savefig(<span class="string">'q1c_value_3D'</span>)

figure(4)
mesh(bb, kk, kPolicy(:,:,1,round((Na+1)/2)));<span class="comment">% yesterday's productivity is mean</span>

<span class="keyword">for</span> ia = 2:Na
    hold <span class="string">on</span>;
    mesh(bb, kk, kPolicy(:,:,ia,round((Na+1)/2)));
<span class="keyword">end</span>

title(<span class="string">'Policy $k^\prime$ Under Different Shocks given mean $z^{-}$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylabel(<span class="string">'Capital Stock $k$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
xlabel(<span class="string">'Debt $b$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
zlabel(<span class="string">'$k^\prime$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
savefig(<span class="string">'q1c_kPolicy_3D'</span>)

figure(5)
mesh(bb, kk, bPolicy(:,:,1,round((Na+1)/2)));<span class="comment">% yesterday's productivity is mean</span>

<span class="keyword">for</span> ia = 2:Na
    hold <span class="string">on</span>;
    mesh(bb, kk, bPolicy(:,:,ia,round((Na+1)/2)));
<span class="keyword">end</span>

title(<span class="string">'Policy $b^\prime$ Under Different Shocks given mean $z^{-}$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylabel(<span class="string">'Capital Stock $k$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
xlabel(<span class="string">'Debt $b$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
zlabel(<span class="string">'$bond^\prime$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
savefig(<span class="string">'q1c_bPolicy_3D'</span>)
</pre><pre class="codeoutput">    "iteration =    1487   difference =   9.9473e-06. Converged"

Elapsed time is 39.263782 seconds.
</pre><img vspace="5" hspace="5" src="HW2_03.png" alt=""> <img vspace="5" hspace="5" src="HW2_04.png" alt=""> <img vspace="5" hspace="5" src="HW2_05.png" alt=""> <h2 id="9">d) Stationary Distribution of Firms</h2><p>Consider now a world with many such firms and no entry or exit. Specifically, suppose that upon hitting the default threshold debt claims are settled so b = 0. The restructured firm continues to operate but with capital, k = 0 and the previous productivity shock, z.</p><p>Note now the setting has changed a little bit from question c). All we have to change is the value function continuation in the bellman equation, where we don't set value of default to zero. We set if to value when k and b are 0. Notice this is the only difference from c).</p><p>1) This period, if the firm % default, instead of setting the value to 0, I set it to value at k=0.0000001 and b=0, and policy function entry is set to equal to the entry when k=0.0000001 and b=0.</p><p>2) Next Period, if the firm % default, instead of setting the valueTomorrow to 0, I set it to value at k=0.0000001 and b=0.</p><p>I use two kinds of endogenous grids to solve the problem - (a-,a,k,b) and (a,n). For the first method, we can easily make both the first and second adjustment, but for the second method where we only have today's networth information, we can only make the second adjustment and assume that today's firms are nondefaulters and the 0 networth denotes defaulters.</p><pre class="codeinput"><span class="comment">% Use multigrid method to speed up iteration</span>
kGridLength           = [15]; <span class="comment">% number of points in grid for capital</span>
Nk = max(kGridLength);
kMin            = 0.000001;
kMax            = 10 * kSteadyState;
grid_b = curvspace(0,kMax,Nb,2)';

<span class="comment">% Required matrices and vectors</span>
<span class="comment">% Dimensionality is k,b,a,aMinus</span>
kPolicyIndex = zeros(kGridLength(1),Nb,Na,Na);
kPolicy = zeros(kGridLength(1),Nb,Na,Na);
bPolicyIndex = zeros(kGridLength(1),Nb,Na,Na);
bPolicy = zeros(kGridLength(1),Nb,Na,Na);

value   = zeros(kGridLength(1),Nb,Na,Na);
value0 = ones(kGridLength(1),Nb,Na,Na); <span class="comment">% initial guess</span>

tic
<span class="keyword">for</span> i=1:length(kGridLength)

    grid_k = curvspace(kMin,kMax,kGridLength(i),2)';

    <span class="comment">% Calculate Default Probability</span>
    mCutOffValue = zeros(kGridLength(i),Nb);
    mDefaultProbability = zeros(kGridLength(i),Nb,Na);
    vDenominator = grid_k.^aalphaK .* (aalphaL * grid_k.^aalphaK / W).^(aalphaL/(1-aalphaL)) - W * (aalphaL * grid_k.^aalphaK/W).^(1/(1-aalphaL));

    <span class="keyword">for</span> ib = 1:Nb
        vNumerator =  (grid_b(ib) - (1-ddelta)*grid_k)/(1-ttaoC);
        vCutOffValue = vNumerator ./vDenominator;
        mCutOffValue(:,ib) = vCutOffValue; <span class="comment">% cutoff value^(1-aalphaL) is cutoff productivity, but I don't use productivity per se in order to avoid complex numbers</span>
        <span class="keyword">for</span> ia = 1:Na
            <span class="keyword">for</span> ik = 1:kGridLength(1)
                 temp= (vCutOffValue(ik) &gt; grid_a.^(1/(1-aalphaL)));
                mDefaultProbability(ik,ib,ia) = sum(temp.* m_a_prob(ia,:)');
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    mRf = Rf*ones(kGridLength(1),Nb,Na);
    mCarryOnProbability = 1-mDefaultProbability;
    mIsDefaultNextPeriod = (mDefaultProbability==1);
    mRb = min(Rf/mCarryOnProbability,1000000);

    tolerance = 0.00001;
    iteration = 0;
    distance = 100;

    kPrime = repmat(grid_k,1,Nb); <span class="comment">% Nk*Nb matrix</span>
    bondPrime = repmat(grid_b',kGridLength(i),1); <span class="comment">% Nk*Nb matrix</span>

    tic
    <span class="keyword">while</span> distance &gt; tolerance
        <span class="keyword">for</span> ia=1:Na
            a = grid_a(ia);
            isDefaultNextPeriod = mIsDefaultNextPeriod(:,:,ia);

            <span class="keyword">for</span> ik=1:kGridLength(i)
                k = grid_k(ik);
                profit = profitNkByNa(ik,ia);
                investment = investmentFunction(k,kPrime,isDefaultNextPeriod); <span class="comment">% Nk*Nb matrix</span>

                <span class="keyword">for</span> iaMinus = 1:Na
                    RbMinus = mRb(:,:,iaMinus); <span class="comment">% Nk*Nb matrix</span>
                    aMinus = grid_a(iaMinus);

                    <span class="keyword">for</span> ib = 1:Nb
                        bond = grid_b(ib);

                        <span class="keyword">if</span> (1-ttaoC)*profit + (1-ddelta)*k &lt;= bond
                            value (ik,ib,ia,iaMinus)=value0(1,1,ia,iaMinus);

                            kPolicyIndex(ik,ib,ia,iaMinus) = kPolicyIndex(1,1,ia,iaMinus) ;
                            bPolicyIndex(ik,ib,ia,iaMinus) = bPolicyIndex(1,1,ia,iaMinus) ;

                            kPolicy(ik,ib,ia,iaMinus) = grid_k(kPolicyIndex(1,1,ia,iaMinus));
                            bPolicy(ik,ib,ia,iaMinus) = grid_b(bPolicyIndex(1,1,ia,iaMinus));

                        <span class="keyword">else</span>

                            taxPayments = taxPaymentsFunction(k,bond,profit,RbMinus); <span class="comment">% Nk*Nb matrix</span>
                            divident = dividentFunction(profit,investment,bond,bondPrime,RbMinus,taxPayments,isDefaultNextPeriod); <span class="comment">% Nk*Nb matrix</span>

                            valueTomorrow = zeros(kGridLength(i),Nb,Na);<span class="comment">% k',b',a'</span>

                            <span class="keyword">for</span> iaPrime = 1:Na <span class="comment">% iterate over all possible states for tomorrow</span>
                                aPrime = grid_a(iaPrime);
                                profitPrime = repmat(profitNkByNa(:,iaPrime),1,Nb);<span class="comment">% Nk*Nb</span>
                                valueTomorrow(:,:,iaPrime) =  m_a_prob(ia,iaPrime) * (value0(:,:,iaPrime,ia).* ((1-ttaoC)*profitPrime + (1-ddelta)*kPrime &gt; bondPrime)<span class="keyword">...</span>
                                    +value0(1,1,iaPrime,ia).* ((1-ttaoC)*profitPrime + (1-ddelta)*kPrime &lt;= bondPrime));<span class="comment">% &ETH;&egrave;&Ograve;&ordf;&iquest;&frac14;&Acirc;&Ccedil;default&Ouml;&reg;&ordm;&oacute;value&sup2;&raquo;&Ecirc;&Ccedil;&Icirc;&ordf;0&pound;&not;&para;&oslash;&Ecirc;&Ccedil;&Icirc;&ordf;set bond and capital to 0&micro;&Auml;value</span>
                            <span class="keyword">end</span>
                            mExpectedValueTomorrow = sum(valueTomorrow,3); <span class="comment">% sum by the third dimension to get a Nk*Nb matrix</span>

                            x = divident + M * mExpectedValueTomorrow;

                            [rows,cols]=find(x==max(max(x)));
                            kPolicyIndex(ik,ib,ia,iaMinus) = min(rows);
                            bPolicyIndex(ik,ib,ia,iaMinus) = min(cols);

                            kPolicy(ik,ib,ia,iaMinus) = grid_k(min(rows));
                            bPolicy(ik,ib,ia,iaMinus) = grid_b(min(cols));
                            value(ik,ib,ia,iaMinus) = max(max(x));
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        distance = sum(sum(sum(sum(abs(value(:,:,:,:)-value0(:,:,:,:))))));
        value0 = value;
        iteration = iteration + 1;

        <span class="comment">%if mod(iteration,5) == 0</span>
        <span class="comment">%    display("iteration =    " + iteration + "   difference =   " + distance )</span>
        <span class="comment">%end</span>
    <span class="keyword">end</span>

    display(<span class="string">"iteration =    "</span> + iteration + <span class="string">"   difference =   "</span> + distance + <span class="string">". Converged"</span>)
    <span class="keyword">if</span> i ~= length(kGridLength)
        value0 = interp1(grid_k,value,linspace(kMin, kMax, kGridLength(i+1)));
        value  = value0;
        kPolicy         = zeros(kGridLength(i+1),Nb,Na,Na);
        kPolicyIndex    = zeros(kGridLength(i+1),Nb,Na,Na);
        bPolicy         = zeros(kGridLength(i+1),Nb,Na,Na);
        bPolicyIndex    = zeros(kGridLength(i+1),Nb,Na,Na);

    <span class="keyword">end</span>

<span class="keyword">end</span>

toc
save(<span class="string">'resultD'</span>,<span class="string">'value'</span>,<span class="string">'kPolicy'</span>,<span class="string">'bPolicy'</span>,<span class="string">'kPolicyIndex'</span>,<span class="string">'bPolicyIndex'</span>)

figure(6);
[bb,kk]=meshgrid(grid_b, grid_k);
mesh(bb, kk, value(:,:,1,round((Na+1)/2)));<span class="comment">% yesterday's productivity is mean</span>

<span class="keyword">for</span> ia = 2:Na
    hold <span class="string">on</span>;
    mesh(bb, kk, value(:,:,ia,round((Na+1)/2)));
<span class="keyword">end</span>

title(<span class="string">'Value Under Different Shocks given mean $z^{-}$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylabel(<span class="string">'Capital Stock $k$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
xlabel(<span class="string">'Debt $b$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
zlabel(<span class="string">'Value'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
savefig(<span class="string">'q1d_value_3D'</span>)

figure(7)
mesh(bb, kk, kPolicy(:,:,1,round((Na+1)/2)));<span class="comment">% yesterday's productivity is mean</span>

<span class="keyword">for</span> ia = 2:Na
    hold <span class="string">on</span>;
    mesh(bb, kk, kPolicy(:,:,ia,round((Na+1)/2)));
<span class="keyword">end</span>

title(<span class="string">'Policy $k^\prime$ Under Different Shocks given mean $z^{-}$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylabel(<span class="string">'Capital Stock $k$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
xlabel(<span class="string">'Debt $b$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
zlabel(<span class="string">'$k^\prime$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
savefig(<span class="string">'q1d_kPolicy_3D'</span>)


figure(8)
mesh(bb, kk, bPolicy(:,:,1,round((Na+1)/2)));<span class="comment">% yesterday's productivity is mean</span>

<span class="keyword">for</span> ia = 2:Na
    hold <span class="string">on</span>;
    mesh(bb, kk, bPolicy(:,:,ia,round((Na+1)/2)));
<span class="keyword">end</span>

title(<span class="string">'Policy $b^\prime$ Under Different Shocks given mean $z^{-}$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylabel(<span class="string">'Capital Stock $k$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
xlabel(<span class="string">'Debt $b$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
zlabel(<span class="string">'$bond^\prime$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
savefig(<span class="string">'q1d_bPolicy_3D'</span>)
</pre><pre class="codeoutput">    "iteration =    1556   difference =   9.9201e-06. Converged"

Elapsed time is 43.931917 seconds.
</pre><img vspace="5" hspace="5" src="HW2_06.png" alt=""> <img vspace="5" hspace="5" src="HW2_07.png" alt=""> <img vspace="5" hspace="5" src="HW2_08.png" alt=""> <p>Stationary Distribution Compute the stationary distribution of firms.</p><pre class="codeinput">distributionStationary0 = (1/(Nk*Nb*Na*Na))*ones(Nk,Nb,Na,Na);
distance=100;
tolerance=0.000001;
iteration=0;

<span class="keyword">while</span> distance&gt;tolerance
    distributionStationary1 = zeros(Nk,Nb,Na,Na);
    <span class="keyword">for</span> ia=1:Na
        <span class="keyword">for</span> iaMinus=1:Na
            <span class="keyword">for</span> ib=1:Nb
                <span class="keyword">for</span> ik=1:Nk
                    ikPrime = kPolicyIndex(ik,ib,ia,iaMinus);
                    ibPrime = bPolicyIndex(ik,ib,ia,iaMinus);

                    prob = distributionStationary0(ik,ib,ia,iaMinus);
                    <span class="keyword">for</span> iaPrime=1:Na
                        prob_aPrime = prob*m_a_prob(ia,iaPrime);
                        distributionStationary1(ikPrime,ibPrime,iaPrime,ia) = distributionStationary1(ikPrime,ibPrime,iaPrime,ia) + prob_aPrime;
                    <span class="keyword">end</span>

                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    distance=sum(sum(sum(sum(abs(distributionStationary0-distributionStationary1)))));
    distributionStationary0 = distributionStationary1;
    iteration = iteration + 1;
<span class="keyword">end</span>
</pre><p>Plot the distribution</p><pre class="codeinput">[bb,kk]=meshgrid(grid_b, grid_k);
aMinusDescription = [<span class="string">"low"</span>,<span class="string">"medium"</span>,<span class="string">"high"</span>];

<span class="keyword">for</span> iaMinus = 1:Na
    figure(8+iaMinus);
    mesh(bb, kk, distributionStationary0(:,:,1,iaMinus));

    <span class="keyword">for</span> ia = 2:Na
        hold <span class="string">on</span>;
        mesh(bb,kk,distributionStationary0(:,:,ia,iaMinus));
    <span class="keyword">end</span>
    title([<span class="string">'Distribution $z^{-}$ '</span>,aMinusDescription(iaMinus)],<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
    ylabel(<span class="string">'Capital Stock $k^\prime$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
    xlabel(<span class="string">'Debt $b^\prime$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
    zlabel(<span class="string">'Probability Mass'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
<span class="keyword">end</span>

savefig(<span class="string">'q1d_stationary_distribution_3D'</span>)
</pre><img vspace="5" hspace="5" src="HW2_09.png" alt=""> <img vspace="5" hspace="5" src="HW2_10.png" alt=""> <img vspace="5" hspace="5" src="HW2_11.png" alt=""> <p>Use the invariant distribution to construct a table reporting the cross-sectional average values of:</p><p>(1) probability of default, p();</p><p>(2) required return on risky bonds, Rb();</p><p>(3) leverage ratio, b/k;</p><p>(4) investment to capital ratio, i/k.</p><p>(5) fraction of firms issuing equity;</p><p>To solve this question, we create a 4-dimensional array in order to reduce the layer of loops.</p><pre class="codeinput">mK4D=repmat(grid_k,1,Nb,Na,Na);<span class="comment">% Nk*Nb*Na*Na matrix</span>
mBond4D=repmat(grid_b',Nk,1,Na,Na); <span class="comment">% Nk*Nb*Na*Na matrix</span>

mA4D=repmat(grid_a',Na,1,Nb,Nk);
mA4D=permute(mA4D,[4,3,2,1]);<span class="comment">% transform/reallocate the dimension to get a Nk*Nb*Na*Na matrix</span>

mAMinus4D=repmat(grid_a,1,Na,Nb,Nk);
mAMinus4D=permute(mAMinus4D,[4,3,2,1]);<span class="comment">% transform/reallocate the dimension to get a Nk*Nb*Na*Na matrix</span>
</pre><p>(1) probability of default, p();</p><pre class="codeinput">mProfit4D = profitFunction(mA4D,mK4D);<span class="comment">% Nk*Nb matrix</span>
mDefault4D = 1-nonDefaultFunction(mProfit4D,mK4D,mBond4D);<span class="comment">% Nk*Nb 0-1 matrix</span>
defaultProbability = sum(sum(sum(sum(mDefault4D.*distributionStationary0))));
fprintf(<span class="string">'Average Default Probability is %2.10f\n'</span>, defaultProbability);
</pre><pre class="codeoutput">Average Default Probability is 0.0000000036
</pre><p>(2) required return on risky bonds, Rb();</p><pre class="codeinput">riskyBondReturn = sum(sum(sum(sum((min(10000000000000,Rf/(1-mDefault4D))).*((mDefault4D~=1).*distributionStationary0)))));
fprintf(<span class="string">'Required return on risky bonds on average is %2.8f\n'</span>, riskyBondReturn);
</pre><pre class="codeoutput">Required return on risky bonds on average is 1.01010101
</pre><pre>As we can see, the result implies that corporate bonds are effectively riskfree.</pre><p>(3) leverage ratio, b/k;</p><pre class="codeinput">leverageRatio = sum(sum(sum(sum(mBond4D ./ mK4D   .*distributionStationary0))));
fprintf(<span class="string">'Average leverage ratio is %2.8f\n'</span>, leverageRatio);
</pre><pre class="codeoutput">Average leverage ratio is 0.53968518
</pre><p>(4) investment to capital ratio, i/k.</p><pre class="codeinput">investment2Capital=sum(sum(sum(sum((kPolicy./mK4D + 1 - ddelta).*distributionStationary0))));
fprintf(<span class="string">'Average investment to capital ratio is %2.8f\n'</span>, investment2Capital);
</pre><pre class="codeoutput">Average investment to capital ratio is 2.00309413
</pre><p>(5) fraction of firms issuing equity;</p><pre class="codeinput">mIsDefaultNextPeriod4D = zeros(kGridLength(1),Nb,Na,Na);
<span class="keyword">for</span> iaMinus=1:Na
    aMinus = grid_a(iaMinus);
    mIsDefaultNextPeriod4D(:,:,:,iaMinus)=mIsDefaultNextPeriod;
<span class="keyword">end</span>

mRbMinus4D = zeros(kGridLength(1),Nb,Na,Na);
<span class="keyword">for</span> ia = 1:Na
    a = grid_a(ia);
    <span class="keyword">for</span> iaMinus = 1:Na
        aMinus = grid_a(iaMinus);
        mRbMinus4D(:,:,ia,iaMinus)=mRb(:,:,iaMinus);
    <span class="keyword">end</span>
<span class="keyword">end</span>

mInvestment4D = investmentFunction(mK4D,mK4D,mIsDefaultNextPeriod4D);
mTaxPayments4D = taxPaymentsFunction(mK4D,mBond4D,mProfit4D,mRbMinus4D);
mDivident4D = dividentFunction(mProfit4D,mInvestment4D,mBond4D,mBond4D,mRbMinus4D,mTaxPayments4D,mIsDefaultNextPeriod4D);

mIsIssuingEquity = (mDivident4D&lt;0);
fractionOfFirmsIssuingEquity = sum(sum(sum(sum(  mIsIssuingEquity .*distributionStationary0))));
fprintf(<span class="string">'The fraction of firms issuing equity is %2.8f\n'</span>, fractionOfFirmsIssuingEquity);

table(defaultProbability,riskyBondReturn,leverageRatio,investment2Capital,fractionOfFirmsIssuingEquity)
</pre><pre class="codeoutput">The fraction of firms issuing equity is 0.03029629

ans =

  1&times;5 table

    defaultProbability    riskyBondReturn    leverageRatio    investment2Capital    fractionOfFirmsIssuingEquity
    __________________    _______________    _____________    __________________    ____________________________

        3.5699e-09            1.0101            0.53969             2.0031                    0.030296          

</pre><h2 id="29">Part II: Method of Simulated Moments</h2><pre class="codeinput"><span class="comment">% Housekeeping.</span>
clear;
close <span class="string">all</span>;
</pre><p>Parametization.</p><pre class="codeinput">M = 0.99;
Rf = 1/M;
r = 1/M-1; <span class="comment">% interest rate for notation convenience</span>
ddelta = 0.1;
aalphaK = 0.3;
aalphaL = 0.6;
W = 2; <span class="comment">% wage</span>
llambda = 0.025; <span class="comment">% proportional cost of issuing equity</span>
ttaoC=0.15; <span class="comment">% corporate tax rate</span>

Nk = 20;
kMin = 0.00001;
kSteadyState = 1;
<span class="comment">% a_grid and a's transition matrix</span>
m = 3; <span class="comment">% parameter for tauchen method</span>
Na = 5;
ssigma = 0.05;
Nb = 15;
tolerance=0.00001;
</pre><p>We create a grid of rho and lambda.</p><pre class="codeinput">kGridLength = [15]; <span class="comment">% number of points in grid for capital</span>
numsteps = 1000;

vOtherCoefs= [M ddelta aalphaK, aalphaL, W, ttaoC, Nk, kMin, kSteadyState];
vOtherCoefs= [vOtherCoefs m Na ssigma Nb tolerance]; <span class="comment">%size 14</span>

Vinit = ones(kGridLength(1),Nb,Na,Na); <span class="comment">% initial guess</span>


vRhos = [0.5 0.6 0.7 0.8 0.9];
vLambdas = [ 0.01 0.02 0.025 0.03 0.05];
numRhos = length(vRhos);
numLambdas = length(vLambdas);
numCoefs = 9; <span class="comment">% rho, lambda, beta0-beta2, gamma0-gamma3</span>
coefficients = zeros(numRhos*numLambdas,numCoefs);

ii = 0;
j = 0;
<span class="keyword">for</span> rrho= vRhos
    ii = ii+1;
    coefficients(((ii-1)*numLambdas +1):(ii*numLambdas),1) = rrho;
    j = 0;
    <span class="keyword">for</span> llambda = vLambdas
        j = j+1;
        coefficients((ii-1)*numLambdas+j,2) = llambda;
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p>We now get the coefficients from code of 1.d) for each rho/lambda.</p><p>Here, we run the code from 1.d) with the different values of lambda and rho.</p><p>The function `funVectorCoefs` wraps the calculations of the value function and the steady state as in parts 1.c) and 1.d). Additionally, it runs a regression and saves the estimated parameters.</p><pre class="codeinput">ii = 0;
j = 0;
<span class="keyword">for</span> rrho= vRhos
    ii = ii+1;
    j = 0;
    <span class="keyword">for</span> llambda = vLambdas
        j = j+1;
        [vectorCoefs, Vnew] = funVectorCoefs(rrho,llambda, Vinit,vOtherCoefs,<span class="keyword">...</span>
            kGridLength,0, numsteps); <span class="comment">%vectorCoefs = 1:7;</span>
        Vinit = Vnew;
        coefficients((ii-1)*numLambdas+j,3:numCoefs) = vectorCoefs;
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p>We now find the optimal coefficients.</p><pre class="codeinput"><span class="comment">%once we have the coefficients, we just see which one is the closest one to the one given</span>
betaObjective = [0.004 0.02 -0.15 -0.4 0.05]; <span class="comment">%b1, b2, g1,g2,g3</span>

<span class="comment">%get rid of beta0 and gamma0</span>
coefToCompare = coefficients(:,[4,5,7,8,9]);
errors = zeros(numRhos*numLambdas,1);

<span class="comment">% find the best coefficients w.r.to the norm2 distance vs the given coefs.</span>
errors(1) = norm(coefToCompare(1,:) - betaObjective,2);
minerror = errors(1);
minerrorii = 1;
<span class="keyword">for</span> ii=2:(numRhos*numLambdas)
    errors(ii) = norm(coefToCompare(ii,:) - betaObjective,2);
    <span class="keyword">if</span> errors(ii) &lt; errors(ii-1)
        minerror = errors(ii);
        minerrorii = ii;
    <span class="keyword">end</span>
<span class="keyword">end</span>
display([<span class="string">'The best coefficients found are: rho = '</span>, num2str(coefficients(minerrorii,1)), <span class="string">' and lambda = '</span>, num2str(coefficients(minerrorii,2))]);
</pre><pre class="codeoutput">The best coefficients found are: rho = 0.9 and lambda = 0.03
</pre><h2 id="36">Part III: Optimal Default</h2><p>First we need to decide on the default behavior - once default, will the firm continue to run the firm as the ownership with 0 capital and 0 bond as in question 1(d), or will its ownership be changed and thus value put to 0?</p><p>It is implied in the Bellman equation that, once default, firms exit the market, since next period we are choosing between 0 and e(z',k',b'), not between e(z',0,0) and e(z',k',b').</p><p>Housekeeping</p><pre class="codeinput">clear;
close <span class="string">all</span>;
</pre><p>Parametization.</p><pre class="codeinput">M = 0.99;
Rf = 1/M;
RbConstant = 1.01 * Rf;
r = 1/M-1; <span class="comment">% risk free interest rate for notation convenience</span>
ddelta = 0.1;
aalphaK = 0.3;
aalphaL = 0.6;
W = 2; <span class="comment">% wage</span>
llambda = 0.025; <span class="comment">% proportional cost of issuing equity</span>
ttaoC=0.15; <span class="comment">% corporate tax rate</span>
</pre><p>a_grid, m_a_prob and a's transition probability matrix</p><pre class="codeinput">kSteadyState = 1;
tempK = kSteadyState^((aalphaK+aalphaL-1)/(1-aalphaL));
aMean = ((r+ddelta)/aalphaK/tempK)^(1-aalphaL)*(W/aalphaL)^aalphaL; <span class="comment">% set a such that k_SteadyState equals how much you set it to be;</span>

<span class="comment">% a_grid and a's transition matrix</span>
m = 3; <span class="comment">% parameter for tauchen method</span>
Na = 3;
rrho = 0.7;
ssigma = 0.05;
[grid_a_log,m_a_prob] = tauchen(Na,log(aMean),rrho,ssigma,m);
grid_a = exp(grid_a_log)';
<span class="comment">% grid_a_minus = grid_a;</span>
aMax = max(grid_a);

<span class="comment">% k_grid</span>
kMax = (aMax/ddelta)^(1/(1-aalphaK));
kMax = min(2*kSteadyState, kMax); <span class="comment">% Tighten the grid</span>
<span class="comment">% grid_k = curvspace(kMin,kMax,Nk,2)'; % I use curved grid to enhance accuracy</span>

<span class="comment">% b_grid grid for bond</span>
<span class="comment">% b_grid should be finer to see the difference in default probability under different productivity shocks at steady state</span>
Nb = 20;
grid_b = curvspace(0,kMax,Nb,2)'; <span class="comment">% To cover up as wide leverage level as possible</span>

<span class="comment">% invariant distribution of a_grid - vDistribution_a0</span>
vDistribution_a0=( 1/Na )*ones(Na,1); <span class="comment">% initial guess</span>
vDistribution_a=vDistribution_a0;
distance=100; tolerance=0.00001;
iteration = 0;
<span class="keyword">while</span> distance&gt;tolerance
    distribution = vDistribution_a'*m_a_prob;
    distance=sum(abs(distribution-vDistribution_a'));
    vDistribution_a = distribution';
    iteration = iteration+1;
<span class="keyword">end</span>

clear <span class="string">vDistribution_a0</span> <span class="string">distribution</span>;
</pre><p>Create functions for convenience</p><pre class="codeinput">profitFunction = @(a,k)a.* k.^aalphaK.* ((k.^aalphaK * aalphaL).* a/W).^(aalphaL/(1-aalphaL)) - W * ((k.^aalphaK * aalphaL).* a/W).^(1/(1-aalphaL));
investmentFunction = @(k,kPrime)kPrime - (1-ddelta)*k; <span class="comment">%k_prime usually is k_grid</span>
taxPaymentsFunction = @(k,bond,profit,RbMinus)ttaoC * (profit - ddelta*k - bond * (RbMinus-1)); <span class="comment">% note the non-default indicator</span>

dividentFunction = @(profit,investment,bond,bondPrime,RbMinus,taxPayments,mIsDefaultNextPeriod)(profit - investment  <span class="keyword">...</span>
    + bondPrime.*(1-mIsDefaultNextPeriod) - RbMinus.* bond - taxPayments).*(1 + llambda * ((profit - investment  <span class="keyword">...</span>
    + bondPrime.*(1-mIsDefaultNextPeriod) - RbMinus.* bond - taxPayments) &lt; 0)); <span class="comment">% note the indicator function for issuance cost</span>
</pre><h2 id="42">a) Value Function Iteration when Rb = 1.01Rf</h2><p>Solve the Bellman equation for equity. Plot the optimal investment and default decision for the equity holders.</p><p>State variables: k, b, z Control variables: k',b'</p><p>Considerations:</p><p>a) whether to default this period (using value function&lt;0 this period to decide);</p><p>b) if next period regardless of a', value function is all less than 0, then b' can't be borrowed this much, and thus the firm had to fund the investment by equity.</p><pre class="codeinput"><span class="comment">% Use multigrid method to speed up iteration</span>
kGridLength           = [20]; <span class="comment">% number of points in grid for capital</span>
Nk = max(kGridLength);
kMin            = 0.000001;
kMax            = 7 * kSteadyState;
bMax            = 7 * kSteadyState;
grid_b = curvspace(0,bMax,Nb,2)';

<span class="comment">% Required matrices and vectors</span>
<span class="comment">% Dimensionality is k,b,a,aMinus</span>

kPolicyIndex = zeros(kGridLength(1),Nb,Na);
kPolicy = zeros(kGridLength(1),Nb,Na);
bPolicyIndex = zeros(kGridLength(1),Nb,Na);
bPolicy = zeros(kGridLength(1),Nb,Na);

<span class="comment">% Note default it not a % policy to make for the next period. default is a reaction in this period</span>
<span class="comment">% once productivity shock is realized and you see whether or not the value of the firm is larger than 0 or not.</span>

mValue   = zeros(kGridLength(1),Nb,Na);
mValue0 = ones(kGridLength(1),Nb,Na); <span class="comment">% initial guess</span>

tic
<span class="keyword">for</span> i=1:length(kGridLength)
    grid_k = curvspace(kMin,kMax,kGridLength(i),2)';
    <span class="comment">% Since the profitFunction takes so much time, let's calculate it all</span>
    <span class="comment">% at once to retrieve later</span>
    mANkByNa = repmat(grid_a',kGridLength(i),1);
    mKNkByNa = repmat(grid_k,1,Na);
    profitNkByNa = profitFunction(mANkByNa,mKNkByNa); <span class="comment">% Nk by Na</span>

    tolerance = 0.00001;
    iteration = 0;
    distance = 100;

    kPrimeNkByNb = repmat(grid_k,1,Nb); <span class="comment">% Nk*Nb matrix</span>
    bondPrimeNkByNb = repmat(grid_b',kGridLength(i),1); <span class="comment">% Nk*Nb matrix</span>

    tic
    <span class="keyword">while</span> distance &gt; tolerance
        mIsDefaultNextPeriod = zeros(kGridLength(i),Nb); <span class="comment">% k' b' entry is 1 if it will default for sure next period</span>
        <span class="keyword">for</span> ibPrime = 1:Nb
            <span class="keyword">for</span> ikPrime = 1:kGridLength(i)
                mIsDefaultNextPeriod(ikPrime,ibPrime) = (sum((mValue0(ikPrime,ibPrime,:)&gt;=0)) == 0);
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">for</span> ia=1:Na
            a = grid_a(ia);

            <span class="keyword">for</span> ik=1:kGridLength(i)
                k = grid_k(ik);
                profit = profitNkByNa(ik,ia);<span class="comment">% scalar</span>
                investmentNkByNb = investmentFunction(k,kPrimeNkByNb); <span class="comment">% Nk*Nb matrix</span>

                <span class="keyword">for</span> ib = 1:Nb
                    bond = grid_b(ib);

                    <span class="keyword">if</span> mValue0(ik,ib,ia) &lt;0 <span class="comment">% the firm will exit/default and choose no k' and b'</span>
                        kPolicyIndex(ik,ib,ia) = 0;
                        kPolicy(ik,ib,ia) = 0;
                        bPolicyIndex(ik,ib,ia) = 0;
                        bPolicy(ik,ib,ia) = 0;
                    <span class="keyword">else</span> <span class="comment">% choose policy amongst k's b's</span>
                        taxPayments = taxPaymentsFunction(k,bond,profit,RbConstant); <span class="comment">% scalar</span>
                        divident = dividentFunction(profit,investmentNkByNb,bond,bondPrimeNkByNb,RbConstant,taxPayments,mIsDefaultNextPeriod);<span class="comment">% Nk*Nb matrix</span>

                        <span class="comment">% Next we shall calculate the expected value</span>
                        <span class="comment">% tomorrow. Note we have to apply Max operator</span>
                        <span class="comment">% first and then take expectations - which means</span>
                        <span class="comment">% only when we reach that period will the firm make</span>
                        <span class="comment">% the default/nondefault decision.</span>
                        mValueTomorrow = zeros(kGridLength(i),Nb,Na); <span class="comment">% k',b',a'</span>
                        <span class="keyword">for</span> iaPrime = 1:Na <span class="comment">% iterate over all possible states for tomorrow</span>
                            mValueTomorrow(:,:,iaPrime) = m_a_prob(ia,iaPrime) * <span class="keyword">...</span>
                                (max(0,mValue0(:,:,iaPrime)).*(1-mIsDefaultNextPeriod)<span class="keyword">...</span>
                                + max(0,repmat(mValue0(:,1,iaPrime),1,Nb)).*mIsDefaultNextPeriod);

                        <span class="keyword">end</span>
                        mExpectedValueTomorrow = sum(mValueTomorrow,3); <span class="comment">% sum by the third dimension to get a Nk*Nb matrix</span>

                        x = divident + M * mExpectedValueTomorrow;

                        [rows,cols]=find(x==max(max(x)));

                        kPolicyIndex(ik,ib,ia) = min(rows);
                        bPolicyIndex(ik,ib,ia) = min(cols);

                        kPolicy(ik,ib,ia) = grid_k(min(rows));
                        bPolicy(ik,ib,ia) = grid_b(min(cols));

                        mValue(ik,ib,ia) = max(max(x));

                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        distance = sum(sum(sum(sum(abs(mValue(:,:,:,:)-mValue0(:,:,:,:))))));
        mValue0 = mValue;
        iteration = iteration + 1;

        <span class="comment">%if mod(iteration,5) == 0</span>
        <span class="comment">%    display("iteration =    " + iteration + "   difference =   " + distance )</span>
        <span class="comment">%end</span>
    <span class="keyword">end</span>

    display(<span class="string">"iteration =    "</span> + iteration + <span class="string">"   difference =   "</span> + distance + <span class="string">". Converged"</span>)
    <span class="keyword">if</span> i ~= length(kGridLength)
        mValue0 = interp1(grid_k, mValue,linspace(kMin, kMax, kGridLength(i+1))');<span class="comment">% &Otilde;&acirc;&Agrave;&iuml;&sup2;&raquo;&Ouml;&ordf;&micro;&Agrave;linspace&ordm;&oacute;&Atilde;&aelig;&Ograve;&ordf;&sup2;&raquo;&Ograve;&ordf;&frac14;&Oacute;'&plusmn;&auml;&Icirc;&ordf;&Aacute;&ETH;&Iuml;&ograve;&Aacute;&iquest;&iexcl;&pound;&Ecirc;&Ocirc;&Ecirc;&Ocirc;&deg;&Eacute;</span>
        mValue  = mValue0;
        kPolicy         = zeros(kGridLength(i+1),Nb,Na);
        kPolicyIndex    = zeros(kGridLength(i+1),Nb,Na);
        bPolicy         = zeros(kGridLength(i+1),Nb,Na);
        bPolicyIndex    = zeros(kGridLength(i+1),Nb,Na);
    <span class="keyword">end</span>

<span class="keyword">end</span>

toc
save(<span class="string">'resultA'</span>,<span class="string">'mValue'</span>,<span class="string">'kPolicy'</span>,<span class="string">'bPolicy'</span>,<span class="string">'kPolicyIndex'</span>,<span class="string">'bPolicyIndex'</span>)

figure(1);
[bb,kk]=meshgrid(grid_b, grid_k);
mesh(bb, kk, mValue(:,:,1));<span class="comment">% yesterday's productivity is mean</span>

<span class="keyword">for</span> ia = 2:Na
    hold <span class="string">on</span>;
    mesh(bb, kk, mValue(:,:,ia));
<span class="keyword">end</span>

title(<span class="string">'Value Under Different Shocks'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylabel(<span class="string">'Capital Stock $k$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
xlabel(<span class="string">'Debt $b$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])

zlabel(<span class="string">'Value'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
savefig(<span class="string">'q3a_value_3D'</span>)
</pre><pre class="codeoutput">    "iteration =    90   difference =   8.1524e-06. Converged"

Elapsed time is 5.380841 seconds.
</pre><img vspace="5" hspace="5" src="HW2_12.png" alt=""> <pre class="codeinput">figure(2)
mesh(bb, kk, kPolicy(:,:,1));<span class="comment">% yesterday's productivity is mean</span>

<span class="keyword">for</span> ia = 2:Na
    hold <span class="string">on</span>;
    mesh(bb, kk, kPolicy(:,:,ia));
<span class="keyword">end</span>

title(<span class="string">'Policy $k^\prime$ Under Different Shocks'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylabel(<span class="string">'Capital Stock $k$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
xlabel(<span class="string">'Debt $b$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])

zlabel(<span class="string">'$k^\prime$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
savefig(<span class="string">'q3a_kPolicy_3D'</span>)
</pre><img vspace="5" hspace="5" src="HW2_13.png" alt=""> <pre class="codeinput">figure(3)
mesh(bb, kk, bPolicy(:,:,1));<span class="comment">% yesterday's productivity is mean</span>

<span class="keyword">for</span> ia = 2:Na
    hold <span class="string">on</span>;
    mesh(bb, kk, bPolicy(:,:,ia));
<span class="keyword">end</span>

title(<span class="string">'Policy $b^\prime$ Under Different Shocks'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylabel(<span class="string">'Capital Stock $k$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
xlabel(<span class="string">'Debt $b$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])

zlabel(<span class="string">'$bond^\prime$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
savefig(<span class="string">'q3a_bPolicy_3D'</span>)
</pre><img vspace="5" hspace="5" src="HW2_14.png" alt=""> <p>We plot the optimal investment and default decision for the equity holders.</p><pre class="codeinput">mK3D=repmat(grid_k,1,Nb,Na);<span class="comment">% Nk*Nb*Na matrix</span>
investmentPolicy = kPolicy - (1-ddelta) * mK3D;

figure(4)
mesh(bb, kk, investmentPolicy(:,:,1));<span class="comment">% yesterday's productivity is mean</span>

<span class="keyword">for</span> ia = 2:Na
    hold <span class="string">on</span>;
    mesh(bb, kk, investmentPolicy(:,:,ia));
<span class="keyword">end</span>

title(<span class="string">'Policy $investment^\prime$ Under Different Shocks'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylabel(<span class="string">'Capital Stock $k$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
xlabel(<span class="string">'Debt $b$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
zlabel(<span class="string">'$investment^\prime$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])

savefig(<span class="string">'q3a_investmentPolicy_3D'</span>)
</pre><img vspace="5" hspace="5" src="HW2_15.png" alt=""> <pre class="codeinput">figure(5)
mIsDefaultToday = (mValue&lt;0);
mesh(bb, kk, mIsDefaultToday(:,:,1));<span class="comment">% yesterday's productivity is mean</span>

<span class="keyword">for</span> ia = 2:Na
    hold <span class="string">on</span>;
    mesh(bb, kk, mIsDefaultToday(:,:,ia));
<span class="keyword">end</span>

title(<span class="string">'Whether to Default Today Under Different Shocks'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylabel(<span class="string">'Capital Stock $k$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
xlabel(<span class="string">'Debt $b$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
zlabel(<span class="string">'default'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])

savefig(<span class="string">'q3a_IsDefaultToday_3D'</span>)
</pre><img vspace="5" hspace="5" src="HW2_16.png" alt=""> <p>Compute the stationary distribution to see how good is the range of the grid</p><pre class="codeinput">distributionStationary0 = (1/(Nk*Nb*Na))*ones(Nk,Nb,Na);
distance=100;
tolerance=0.0000000001;
iteration=0;

<span class="keyword">while</span> distance&gt;tolerance
    distributionStationary1 = zeros(Nk,Nb,Na);
    <span class="keyword">for</span> ia=1:Na
        <span class="keyword">for</span> ib=1:Nb
            <span class="keyword">for</span> ik=1:Nk
                ikPrime = max(1,kPolicyIndex(ik,ib,ia));
                ibPrime = max(1,bPolicyIndex(ik,ib,ia));

                prob = distributionStationary0(ik,ib,ia);
                <span class="keyword">for</span> iaPrime=1:Na
                    prob_aPrime = prob*m_a_prob(ia,iaPrime);
                    distributionStationary1(ikPrime,ibPrime,iaPrime) = distributionStationary1(ikPrime,ibPrime,iaPrime) + prob_aPrime;
                <span class="keyword">end</span>


            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    distance=sum(sum(sum(abs(distributionStationary0-distributionStationary1))));
    distributionStationary0 = distributionStationary1;
    iteration = iteration + 1;
<span class="keyword">end</span>
</pre><p>We finally plot the distribution.</p><pre class="codeinput">figure(6);
[bb,kk]=meshgrid(grid_b, grid_k);
mesh(bb, kk, distributionStationary0(:,:,1));
<span class="keyword">for</span> ia = 2:Na
    hold <span class="string">on</span>
    mesh(bb, kk, distributionStationary0(:,:,ia));
<span class="keyword">end</span>

title(<span class="string">'Stationary Distribution'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
ylabel(<span class="string">'Capital Stock $k$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
xlabel(<span class="string">'Debt $b$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
zlabel(<span class="string">'Probability Mass'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])

savefig(<span class="string">'q3a_stationary_distribution_3D'</span>)
</pre><img vspace="5" hspace="5" src="HW2_17.png" alt=""> <h2 id="53">b) Probability of Default Next Period</h2><p>We compute and plot the probability of default next period, conditional on the value of the shocks today p(z; b'; k')</p><pre class="codeinput">mDefaultProbability = zeros(Nk,Nb,Na);<span class="comment">% k',b',a</span>
<span class="keyword">for</span> ibPrime = 1:Nb
    <span class="keyword">for</span> ikPrime = 1:Nk
        <span class="keyword">for</span> ia = 1:Na
            mDefaultProbability(ikPrime,ibPrime,ia) = sum(reshape((mValue(ikPrime,ibPrime,:)&lt;0),1,Na).*m_a_prob(ia,:));
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

figure(7)
mesh(bb, kk, mDefaultProbability(:,:,1));

<span class="keyword">for</span> ia = 2:Na
    hold <span class="string">on</span>;
    mesh(bb, kk, mDefaultProbability(:,:,ia));
<span class="keyword">end</span>

title(<span class="string">'Next Period Default Probability'</span>)
ylabel(<span class="string">'Next Period Capital Stock $k^\prime$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
xlabel(<span class="string">'Next Period Debt $b^\prime$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
zlabel(<span class="string">'Next Period Default Probability'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
zlim([0,1])
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])

savefig(<span class="string">'q3b_default_prob_3D'</span>)
</pre><img vspace="5" hspace="5" src="HW2_18.png" alt=""> <h2 id="54">c) Required Rate of Return of Bonds</h2><p>We now use the conditional default probability to compute the required rate of return by bondholders, Rb(b'; k'; z) that ensures they make 0 profits. We assume that bondholders get paid 0 upon default.</p><pre class="codeinput">mRf = Rf*ones(Nk,Nb,Na);
mCarryOnProbability = 1-mDefaultProbability;
mIsDefaultNextPeriod3D = (mDefaultProbability==1); <span class="comment">% (b'; k'; z)</span>
mRb = Rf/mCarryOnProbability;
</pre><h2 id="55">d) Value Function Iteration given Rb = mRb(k',b',z).</h2><p>We solve the Bellman equation for the equity holders taking as given this new function for the required rate of return by bondholders, Rb().</p><p>Now we have to keep track of a-.</p><p>State variables: k,b,a,a-</p><p>Control variables: k',b'</p><pre class="codeinput"><span class="comment">% Required matrices and vectors</span>
<span class="comment">% Dimensionality is k,b,a,aMinus</span>

kPolicyIndex = zeros(kGridLength(1),Nb,Na,Na);
kPolicy = zeros(kGridLength(1),Nb,Na,Na);
bPolicyIndex = zeros(kGridLength(1),Nb,Na,Na);
bPolicy = zeros(kGridLength(1),Nb,Na,Na);
<span class="comment">% Note default it not a % policy to make for the next period. default is a reaction in this period</span>
<span class="comment">% once productivity shock is realized and you see whether or not the value of the firm is larger than 0 or not.</span>

mValue   = zeros(kGridLength(1),Nb,Na,Na);
mValue0 = ones(kGridLength(1),Nb,Na,Na); <span class="comment">% initial guess</span>


tic
<span class="keyword">for</span> i=1:length(kGridLength)
    grid_k = curvspace(kMin,kMax,kGridLength(i),2)';
    <span class="comment">% Since the profitFunction takes so much time, let's calculate it all</span>
    <span class="comment">% at once to retrieve later</span>
    mANkByNa = repmat(grid_a',kGridLength(i),1);
    mKNkByNa = repmat(grid_k,1,Na);
    profitNkByNa = profitFunction(mANkByNa,mKNkByNa); <span class="comment">% Nk by Na</span>

    tolerance = 0.00001;
    iteration = 0;
    distance = 100;

    kPrimeNkByNb = repmat(grid_k,1,Nb); <span class="comment">% Nk*Nb matrix</span>
    bondPrimeNkByNb = repmat(grid_b',kGridLength(i),1); <span class="comment">% Nk*Nb matrix</span>

    tic
    <span class="keyword">while</span> distance &gt; tolerance
        <span class="comment">% mIsDefaultNextPeriod is already computed.</span>

        <span class="keyword">for</span> ia=1:Na
            a = grid_a(ia);
            mIsDefaultNextPeriod2D = mIsDefaultNextPeriod3D(:,:,ia); <span class="comment">% Nk*Nb matrix</span>

            <span class="keyword">for</span> ik=1:kGridLength(i)
                k = grid_k(ik);
                profit = profitNkByNa(ik,ia);<span class="comment">% scalar</span>
                investmentNkByNb = investmentFunction(k,kPrimeNkByNb); <span class="comment">% Nk*Nb matrix</span>

                <span class="keyword">for</span> ib = 1:Nb
                    bond = grid_b(ib);

                    <span class="keyword">for</span> iaMinus = 1:Na
                        RbMinus = mRb(ik,ib,iaMinus); <span class="comment">% scalar</span>

                        <span class="keyword">if</span> mValue0(ik,ib,ia,iaMinus) &lt;0 <span class="comment">% the firm will exit/default and choose no k' and b'</span>
                            kPolicyIndex(ik,ib,ia,iaMinus) = 0;
                            kPolicy(ik,ib,ia,iaMinus) = 0;
                            bPolicyIndex(ik,ib,ia,iaMinus) = 0;
                            bPolicy(ik,ib,ia,iaMinus) = 0;
                        <span class="keyword">else</span> <span class="comment">% choose policy amongst k's b's</span>
                            taxPayments = taxPaymentsFunction(k,bond,profit,RbMinus); <span class="comment">% scalar</span>
                            divident = dividentFunction(profit,investmentNkByNb,bond,bondPrimeNkByNb,RbMinus,taxPayments,mIsDefaultNextPeriod2D);<span class="comment">% Nk*Nb matrix</span>

                            <span class="comment">% Next we shall calculate the expected value</span>
                            <span class="comment">% tomorrow. Note we have to apply Max operator</span>
                            <span class="comment">% first and then take expectations - which means</span>
                            <span class="comment">% only when we reach that period will the firm make</span>
                            <span class="comment">% the default/nondefault decision.</span>
                            mValueTomorrow = zeros(kGridLength(i),Nb,Na); <span class="comment">% k',b',a'</span>
                            <span class="keyword">for</span> iaPrime = 1:Na <span class="comment">% iterate over all possible states for tomorrow</span>
                                mValueTomorrow(:,:,iaPrime) = m_a_prob(ia,iaPrime) * <span class="keyword">...</span>
                                    (max(0,mValue0(:,:,iaPrime)).*(1-mIsDefaultNextPeriod2D)<span class="keyword">...</span>
                                    + max(0,repmat(mValue0(:,1,iaPrime),1,Nb)).*mIsDefaultNextPeriod2D);

                            <span class="keyword">end</span>
                            mExpectedValueTomorrow = sum(mValueTomorrow,3); <span class="comment">% sum by the third dimension to get a Nk*Nb matrix</span>

                            x = divident + M * mExpectedValueTomorrow;

                            [rows,cols]=find(x==max(max(x)));

                            kPolicyIndex(ik,ib,ia,iaMinus) = min(rows);
                            bPolicyIndex(ik,ib,ia,iaMinus) = min(cols);

                            kPolicy(ik,ib,ia,iaMinus) = grid_k(min(rows));
                            bPolicy(ik,ib,ia,iaMinus) = grid_b(min(cols));

                            mValue(ik,ib,ia,iaMinus) = max(max(x));

                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        distance = sum(sum(sum(sum(abs(mValue(:,:,:,:)-mValue0(:,:,:,:))))));
        mValue0 = mValue;
        iteration = iteration + 1;

        <span class="comment">%if mod(iteration,5) == 0</span>
        <span class="comment">%    display("iteration =    " + iteration + "   difference =   " + distance )</span>
        <span class="comment">%end</span>
    <span class="keyword">end</span>

    display(<span class="string">"iteration =    "</span> + iteration + <span class="string">"   difference =   "</span> + distance + <span class="string">". Converged"</span>)
    <span class="keyword">if</span> i ~= length(kGridLength)
        mValue0 = interp1(grid_k, mValue,linspace(kMin, kMax, kGridLength(i+1))');
        mValue  = mValue0;
        kPolicy         = zeros(kGridLength(i+1),Nb,Na,Na);
        kPolicyIndex    = zeros(kGridLength(i+1),Nb,Na,Na);
        bPolicy         = zeros(kGridLength(i+1),Nb,Na,Na);
        bPolicyIndex    = zeros(kGridLength(i+1),Nb,Na,Na);
    <span class="keyword">end</span>

<span class="keyword">end</span>

toc
save(<span class="string">'resultD'</span>,<span class="string">'mValue'</span>,<span class="string">'kPolicy'</span>,<span class="string">'bPolicy'</span>,<span class="string">'kPolicyIndex'</span>,<span class="string">'bPolicyIndex'</span>)
</pre><pre class="codeoutput">    "iteration =    101   difference =   8.1365e-06. Converged"

Elapsed time is 16.882517 seconds.
</pre><pre class="codeinput">figure(8);
[bb,kk]=meshgrid(grid_b, grid_k);
mesh(bb, kk, mValue(:,:,1,round((Na+1)/2)));<span class="comment">% yesterday's productivity is mean</span>

<span class="keyword">for</span> ia = 2:Na
    hold <span class="string">on</span>;
    mesh(bb, kk, mValue(:,:,ia,round((Na+1)/2)));
<span class="keyword">end</span>

title(<span class="string">'Value Under Different Shocks given mean $z^{-}$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylabel(<span class="string">'Capital Stock $k$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
xlabel(<span class="string">'Debt $b$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
zlabel(<span class="string">'Value'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])

zlim([-max(max(max(max(mValue)))),max(max(max(max(mValue))))])
<span class="comment">% legend('low productivity','median productivity','high productivity') % no use in mesh</span>
savefig(<span class="string">'q3d_value_3D'</span>)
</pre><img vspace="5" hspace="5" src="HW2_19.png" alt=""> <pre class="codeinput">figure(9)
mesh(bb, kk, kPolicy(:,:,1,round((Na+1)/2)));<span class="comment">% yesterday's productivity is mean</span>

<span class="keyword">for</span> ia = 2:Na
    hold <span class="string">on</span>;
    mesh(bb, kk, kPolicy(:,:,ia,round((Na+1)/2)));
<span class="keyword">end</span>

title(<span class="string">'Policy $k^\prime$ Under Different Shocks given mean $z^{-}$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylabel(<span class="string">'Capital Stock $k$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
xlabel(<span class="string">'Debt $b$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
zlabel(<span class="string">'$k^\prime$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
<span class="comment">% legend('low productivity','median productivity','high productivity') % no use in mesh</span>
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])

savefig(<span class="string">'q3d_kPolicy_3D'</span>)
</pre><img vspace="5" hspace="5" src="HW2_20.png" alt=""> <pre class="codeinput">figure(10)
mesh(bb, kk, bPolicy(:,:,1,round((Na+1)/2)));<span class="comment">% yesterday's productivity is mean</span>

<span class="keyword">for</span> ia = 2:Na
    hold <span class="string">on</span>;
    mesh(bb, kk, bPolicy(:,:,ia,round((Na+1)/2)));
<span class="keyword">end</span>

title(<span class="string">'Policy $b^\prime$ Under Different Shocks given mean $z^{-}$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylabel(<span class="string">'Capital Stock $k$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
xlabel(<span class="string">'Debt $b$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
zlabel(<span class="string">'$bond^\prime$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])
savefig(<span class="string">'q3d_bPolicy_3D'</span>)
</pre><img vspace="5" hspace="5" src="HW2_21.png" alt=""> <p>Compute the stationary distribution to see how good is the range of the grid</p><pre class="codeinput">distributionStationary0 = (1/(Nk*Nb*Na*Na))*ones(Nk,Nb,Na,Na);
distance=100;
tolerance=0.0000000001;
iteration=0;

<span class="keyword">while</span> distance&gt;tolerance
    distributionStationary1 = zeros(Nk,Nb,Na,Na);
    <span class="keyword">for</span> ia=1:Na
        <span class="keyword">for</span> iaMinus=1:Na
            <span class="keyword">for</span> ib=1:Nb
                <span class="keyword">for</span> ik=1:Nk
                    ikPrime = max(1,kPolicyIndex(ik,ib,ia,iaMinus));
                    ibPrime = max(1,bPolicyIndex(ik,ib,ia,iaMinus));

                    prob = distributionStationary0(ik,ib,ia,iaMinus);
                    <span class="keyword">for</span> iaPrime=1:Na
                        prob_aPrime = prob*m_a_prob(ia,iaPrime);
                        distributionStationary1(ikPrime,ibPrime,iaPrime,ia) = distributionStationary1(ikPrime,ibPrime,iaPrime,ia) + prob_aPrime;
                    <span class="keyword">end</span>

                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    distance=sum(sum(sum(sum(abs(distributionStationary0-distributionStationary1)))));
    distributionStationary0 = distributionStationary1;
    iteration = iteration + 1;
<span class="keyword">end</span>
</pre><p>Plot the distribution.</p><pre class="codeinput">figure(11);
[bb,kk]=meshgrid(grid_b, grid_k);
mesh(bb, kk, distributionStationary0(:,:,1,1));
<span class="keyword">for</span> iaMinus = 2:Na
    <span class="keyword">for</span> ia = 2:Na
        hold <span class="string">on</span>
        mesh(bb, kk, distributionStationary0(:,:,ia,iaMinus));
    <span class="keyword">end</span>
<span class="keyword">end</span>
title(<span class="string">'Stationary Distribution'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
ylabel(<span class="string">'Capital Stock $k$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
xlabel(<span class="string">'Debt $b$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
zlabel(<span class="string">'Probability Mass'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])

savefig(<span class="string">'q3d_stationary_distribution_3D'</span>)
</pre><img vspace="5" hspace="5" src="HW2_22.png" alt=""> <p>Plot this new value function against the one found in section a).</p><pre class="codeinput">figure(12);
[bb,kk]=meshgrid(grid_b, grid_k);

load(<span class="string">'resultA.mat'</span>)
mesh(bb, kk, mValue(:,:,1));

<span class="keyword">for</span> ia = 2:Na
    hold <span class="string">on</span>;
    mesh(bb, kk, mValue(:,:,ia));
<span class="keyword">end</span>
title(<span class="string">'Value Functions a)'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylabel(<span class="string">'Capital Stock $k$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
xlabel(<span class="string">'Debt $b$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])
zlim([-max(max(max(max(mValue)))),max(max(max(max(mValue))))])
zlabel(<span class="string">'Value'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
savefig(<span class="string">'q3d_value_3D_resultA_and_resultD1'</span>)

figure(13);
load(<span class="string">'resultD.mat'</span>)
mesh(bb, kk, mValue(:,:,1));
<span class="keyword">for</span> ia = 2:Na
    hold <span class="string">on</span>;
    mesh(bb, kk, mValue(:,:,ia));
<span class="keyword">end</span>
title(<span class="string">'Value Functions d)'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylabel(<span class="string">'Capital Stock $k$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
xlabel(<span class="string">'Debt $b$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])
zlim([-max(max(max(max(mValue)))),max(max(max(max(mValue))))])
zlabel(<span class="string">'Value'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
savefig(<span class="string">'q3d_value_3D_resultA_and_resultD2'</span>)
</pre><img vspace="5" hspace="5" src="HW2_23.png" alt=""> <img vspace="5" hspace="5" src="HW2_24.png" alt=""> <p>As we can see from the picture, the difference is only at the region where capital is extremely low and bond is extremely high.</p><p>This makes sense, because in a model where interest rate on risky bond does not depend on the default risk but is exogenously given, there will hardly be negative values because you won't pay very high interest rate even though your default probability is almost 1, or exactly one. That case, if you don't default, you just pay a relatively low interest rate and if you default because the value would be negative if you didn't, the supposed negative value cannot be too negative because the interest rate is just 1.01 times the riskfree rate.</p><p>On the other hand, in a model where interest rate on risky bond does depend on the default risk, once you ask for a very risky debt, the interest rate is so high that once there is a low productivity shock next period, you are more willing to default because if you chose not to, the value would be very very negative because you would have to pay a super high interest rate for the high risk debt you asked for last period.</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Finance 937 - Problem Set 2
% Shasha Wang, Rodrigo Morales Mendoza, Pawel Bednarek

%% Part I: Liquidity/Covenant Default
% Housekeeping

clear;
close all;

%%
% Parametization.
M = 0.99;
Rf = 1/M;
r = 1/M-1; % interest rate for notation convenience
ddelta = 0.1;
aalphaK = 0.3;
aalphaL = 0.6;
W = 2; % wage
llambda = 0.025; % proportional cost of issuing equity
ttaoC=0.15; % corporate tax rate

%%
% k_grid, b_grid, a_grid, m_a_prob and a's transition probability matrix.
Nk = 20;
kMin = 0.00001;

kSteadyState = 1;
tempK = kSteadyState^((aalphaK+aalphaL-1)/(1-aalphaL));
aMean = ((r+ddelta)/aalphaK/tempK)^(1-aalphaL)*(W/aalphaL)^aalphaL; % set a such that k_SteadyState equals how much you set it to be;

% a_grid and a's transition matrix
m = 3; % parameter for tauchen method
Na = 3;
rrho = 0.7;
ssigma = 0.05;
[grid_a_log,m_a_prob] = tauchen(Na,log(aMean),rrho,ssigma,m);
grid_a = exp(grid_a_log)';
grid_a_minus = grid_a;
aMax = max(grid_a);

% k_grid
kMax = (aMax/ddelta)^(1/(1-aalphaK));
kMax = min(2*kSteadyState, kMax); % Tighten the grid
grid_k = curvspace(kMin,kMax,Nk,2)'; % I use curved grid to enhance accuracy

% b_grid grid for bond
% b_grid should be finer to see the difference in default probability under different productivity shocks at steady state
Nb = 15;
grid_b = curvspace(0,kMax,Nb,2)'; % To cover up as wide leverage level as possible

% invariant distribution of a_grid - vDistribution_a0
vDistribution_a0=( 1/Na )*ones(Na,1); % initial guess
vDistribution_a=vDistribution_a0;
distance=100; tolerance=0.00001;
iteration = 0;
while distance>tolerance
    distribution = vDistribution_a'*m_a_prob;
    distance=sum(abs(distribution-vDistribution_a'));
    vDistribution_a = distribution';
    iteration = iteration+1;
end

clear vDistribution_a0 distribution;
%% a) Probability of Default Next Period
% Compute and plot the probability of default next period, 
% conditional on the value of the shocks today p(z,b',k').

%%
% Also, rewrite profit = a^(1/(1-aalphaL)) * (k.^aalphaK .* (aalphaL * k.^aalphaK / W).^(aalphaL/(1-aalphaL)) - W * (aalphaL * k.^aalphaK/W).^(1/(1-aalphaL)));
% once we plug in the FOC for labor.

mCutOffValue = zeros(Nk,Nb);
mDefaultProbability = zeros(Nk,Nb,Na);

vDenominator = grid_k.^aalphaK .* (aalphaL * grid_k.^aalphaK / W).^(aalphaL/(1-aalphaL)) - W * (aalphaL * grid_k.^aalphaK/W).^(1/(1-aalphaL));

for ib = 1:Nb
    vNumerator =  (grid_b(ib) - (1-ddelta)*grid_k)/(1-ttaoC);
%     vCutOffValue = (vNumerator ./v_Denominator).^(1-aalphaL); % I droped
%     this line because it generates complex numbers
    vCutOffValue = vNumerator ./vDenominator;
    mCutOffValue(:,ib) = vCutOffValue; % cutoff value^(1-aalphaL) is cutoff productivity, but I don't use productivity per se in order to avoid complex numbers
    for ia = 1:Na
        for ik = 1:Nk
             temp= (vCutOffValue(ik) > grid_a.^(1/(1-aalphaL)));
            mDefaultProbability(ik,ib,ia) = sum(temp.* m_a_prob(ia,:)');
        end
    end
end
            
% plot the 3D matrix layer by layer
figure(1);
[bb,kk]=meshgrid(grid_b, grid_k);
mesh(bb, kk, mDefaultProbability(:,:,1));

for ia = 2:Na
    hold on;
    mesh(bb, kk, mDefaultProbability(:,:,ia));    
end

title('Next Period Default Probability')
ylabel('Next Period Capital Stock $k^\prime$','interpreter','latex')
xlabel('Next Period Debt $b^\prime$','interpreter','latex')
zlabel('Next Period Default Probability','interpreter','latex')
zlim([0,1])
savefig('q1a_default_prob_3D')

% plot a 2D default risk graph in steady state k=1
% we cannot tell from the graph differences among different productivity
% situations
figure(2)
[v,ind] = max(-abs(grid_k - kSteadyState));
plot(grid_b,mDefaultProbability(ind,:,1));
for ia=2:Na
    hold on
    plot(grid_b,mDefaultProbability(ind,:,ia));
end
ylim([0,1]);
legend('low productivity','median productivity','high productivity','Location','southeast')
title('Default Probability at Steady State $p(z,k^\prime,b^\prime)$','interpreter','latex')
xlabel('Next Period Debt $b^\prime$','interpreter','latex')
ylabel('Next Period Default Probability','interpreter','latex')
savefig('q1a_default_prob_2D')
%% b) Required Rate of Return of Bonds
% Use the conditional default probability to compute the required rate of return 
% by bondholders, Rb(b'; k'; z) that ensures they make 0 profits. 
% Assume for simplicity bondholders get paid 0 upon default.

mRf = Rf*ones(Nk,Nb,Na);
mCarryOnProbability = 1-mDefaultProbability;
mIsDefaultNextPeriod = (mDefaultProbability==1);

mRb = min(Rf/mCarryOnProbability,1000000);
%%
% Functions
% We create some functions for future convenience.

profitFunction = @(a,k)a.* k.^aalphaK.* ((k.^aalphaK * aalphaL).* a/W).^(aalphaL/(1-aalphaL)) - W * ((k.^aalphaK * aalphaL).* a/W).^(1/(1-aalphaL));
nonDefaultFunction = @ (profit,k,bond)((1-ttaoC)*profit + (1-ddelta)*k > bond);
isDefaultNextPeriod2DFunction = @(ia,mIsDefaultNextPeriod3D)(mIsDefaultNextPeriod3D(:,:,ia));
investmentFunction = @(k,kPrime,mIsDefaultNextPeriod)kPrime.*(1-mIsDefaultNextPeriod) - (1-ddelta)*k; %k_prime usually is k_grid
taxPaymentsFunction = @(k,bond,profit,RbMinus)ttaoC * (profit - ddelta*k - bond.* (RbMinus-1).* ((1-ttaoC)*profit + (1-ddelta)*k > bond)); % note the non-default indicator
dividentFunction = @(profit,investment,bond,bondPrime,RbMinus,taxPayments,mIsDefaultNextPeriod)(profit - investment  ...
    + bondPrime.*(1-mIsDefaultNextPeriod) - RbMinus.* bond - taxPayments).*(1 + llambda * ((profit - investment  ...
    + bondPrime.*(1-mIsDefaultNextPeriod) - RbMinus.* bond - taxPayments) < 0)); % note the indicator function for issuance cost
%% c) Value Function Iteration
% Solve the Bellman equation for the equity holders taking as given the
% function for the required rate of return by bondholders, Rb

% Use multigrid method to speed up iteration
kGridLength           = [15]; % number of points in grid for capital
kMin            = 0.000001;
kMax            = 10 * kSteadyState;
grid_b = curvspace(0,kMax,Nb,2)';

% Required matrices and vectors
% Dimensionality is k,b,a,aMinus
    
kPolicyIndex = zeros(kGridLength(1),Nb,Na,Na);
kPolicy = zeros(kGridLength(1),Nb,Na,Na);
bPolicyIndex = zeros(kGridLength(1),Nb,Na,Na);
bPolicy = zeros(kGridLength(1),Nb,Na,Na);

value   = zeros(kGridLength(1),Nb,Na,Na);
value0 = ones(kGridLength(1),Nb,Na,Na); % initial guess

tic
for i=1:length(kGridLength)
    
    grid_k = curvspace(kMin,kMax,kGridLength(i),2)';
    % Since the profitFunction takes so much time, let's calculate it all
    % at once to retrieve later
    mANkByNa = repmat(grid_a',kGridLength(i),1);
    mKNkByNa = repmat(grid_k,1,Na);
    profitNkByNa = profitFunction(mANkByNa,mKNkByNa); % Nk by Na

    % Calculate Default Probability
    mCutOffValue = zeros(kGridLength(i),Nb);
    mDefaultProbability = zeros(kGridLength(i),Nb,Na);

    vDenominator = grid_k.^aalphaK .* (aalphaL * grid_k.^aalphaK / W).^(aalphaL/(1-aalphaL)) - W * (aalphaL * grid_k.^aalphaK/W).^(1/(1-aalphaL));

    for ib = 1:Nb
        vNumerator =  (grid_b(ib) - (1-ddelta)*grid_k)/(1-ttaoC);

        vCutOffValue = vNumerator ./vDenominator;
        mCutOffValue(:,ib) = vCutOffValue; % cutoff value^(1-aalphaL) is cutoff productivity, but I don't use productivity per se in order to avoid complex numbers
        for ia = 1:Na
            for ik = 1:kGridLength(1)
                 temp= (vCutOffValue(ik) > grid_a.^(1/(1-aalphaL)));
                mDefaultProbability(ik,ib,ia) = sum(temp.* m_a_prob(ia,:)');
            end
        end
    end

    mRf = Rf*ones(kGridLength(1),Nb,Na);
    mIsDefaultNextPeriod = (mDefaultProbability==1);
    mCarryOnProbability = 1-mDefaultProbability;
    mRb = min(Rf/mCarryOnProbability,1000000);
    
    tolerance = 0.00001;
    iteration = 0;
    distance = 100;

    kPrime = repmat(grid_k,1,Nb); % Nk*Nb matrix
    bondPrime = repmat(grid_b',kGridLength(i),1); % Nk*Nb matrix

    tic
    while distance > tolerance
        for ia=1:Na
            a = grid_a(ia);
            isDefaultNextPeriod = mIsDefaultNextPeriod(:,:,ia);
            for ik=1:kGridLength(i)
                k = grid_k(ik);        
                profit = profitNkByNa(ik,ia);% scalar
                investment = investmentFunction(k,kPrime,isDefaultNextPeriod); % Nk*Nb matrix
                for iaMinus = 1:Na
                    RbMinus = mRb(:,:,iaMinus); % Nk*Nb matrix
                    aMinus = grid_a(iaMinus);
                    for ib = 1:Nb
                        bond = grid_b(ib);
                        if (1-ttaoC)*profit + (1-ddelta)*k <= bond
                            value (ik,ib,ia,iaMinus)=0; % You stop operating the firm and stop choosing next period k' and b'
                        else
                            taxPayments = taxPaymentsFunction(k,bond,profit,RbMinus); % Nk*Nb matrix
                            divident = dividentFunction(profit,investment,bond,bondPrime,RbMinus,taxPayments,isDefaultNextPeriod); % Nk*Nb matrix
                            valueTomorrow = zeros(kGridLength(i),Nb,Na); % k',b',a'
                            
                            for iaPrime = 1:Na % iterate over all possible states for tomorrow
                                aPrime = grid_a(iaPrime);
                                profitPrime = repmat(profitNkByNa(:,iaPrime),1,Nb);% Nk*Nb
                                valueTomorrow(:,:,iaPrime) = value0(:,:,iaPrime,ia) * m_a_prob(ia,iaPrime) .* ((1-ttaoC)*profitPrime + (1-ddelta)*kPrime > bondPrime);% ÐèÒª¿¼ÂÇdefaultÖ®ºóvalueÎª0
                            end
                            valueTomorrow = sum(valueTomorrow,3); % sum by the third dimension to get a Nk*Nb matrix
                            x = divident + M * valueTomorrow;
                            [rows,cols]=find(x==max(max(x)));
                            kPolicyIndex(ik,ib,ia,iaMinus) = min(rows);
                            bPolicyIndex(ik,ib,ia,iaMinus) = min(cols);
                            kPolicy(ik,ib,ia,iaMinus) = grid_k(min(rows));
                            bPolicy(ik,ib,ia,iaMinus) = grid_b(min(cols));
                            value(ik,ib,ia,iaMinus) = max(max(x));
                        end
                    end
                end
            end
        end
        distance = sum(sum(sum(sum(abs(value(:,:,:,:)-value0(:,:,:,:))))));
        value0 = value;
        iteration = iteration + 1;
        %if mod(iteration,5) == 0
        %    display("iteration =    " + iteration + "   difference =   " + distance )
        %end
    end
    display("iteration =    " + iteration + "   difference =   " + distance + ". Converged")
    if i ~= length(kGridLength)
        value0 = interp1(grid_k,value,linspace(kMin, kMax, kGridLength(i+1)));
        value  = value0;
        kPolicy         = zeros(kGridLength(i+1),Nb,Na,Na);
        kPolicyIndex    = zeros(kGridLength(i+1),Nb,Na,Na);
        bPolicy         = zeros(kGridLength(i+1),Nb,Na,Na);
        bPolicyIndex    = zeros(kGridLength(i+1),Nb,Na,Na);
    end
end

toc
save('valuePrevious','value')
save('resultC','value','kPolicy','bPolicy','kPolicyIndex','bPolicyIndex')

figure(3);
[bb,kk]=meshgrid(grid_b, grid_k);
mesh(bb, kk, value(:,:,1,round((Na+1)/2)));% yesterday's productivity is mean

for ia = 2:Na
    hold on;
    mesh(bb, kk, value(:,:,ia,round((Na+1)/2)));    
end

title('Value Under Different Shocks given mean $z^{-}$','interpreter','latex')
ylabel('Capital Stock $k$','interpreter','latex')
xlabel('Debt $b$','interpreter','latex')
zlabel('Value','interpreter','latex')
savefig('q1c_value_3D')

figure(4)
mesh(bb, kk, kPolicy(:,:,1,round((Na+1)/2)));% yesterday's productivity is mean

for ia = 2:Na
    hold on;
    mesh(bb, kk, kPolicy(:,:,ia,round((Na+1)/2)));    
end

title('Policy $k^\prime$ Under Different Shocks given mean $z^{-}$','interpreter','latex')
ylabel('Capital Stock $k$','interpreter','latex')
xlabel('Debt $b$','interpreter','latex')
zlabel('$k^\prime$','interpreter','latex')
savefig('q1c_kPolicy_3D')

figure(5)
mesh(bb, kk, bPolicy(:,:,1,round((Na+1)/2)));% yesterday's productivity is mean

for ia = 2:Na
    hold on;
    mesh(bb, kk, bPolicy(:,:,ia,round((Na+1)/2)));    
end

title('Policy $b^\prime$ Under Different Shocks given mean $z^{-}$','interpreter','latex')
ylabel('Capital Stock $k$','interpreter','latex')
xlabel('Debt $b$','interpreter','latex')
zlabel('$bond^\prime$','interpreter','latex')
savefig('q1c_bPolicy_3D')

%% d) Stationary Distribution of Firms
% Consider now a world with many such firms and no entry or exit. Specifically,
% suppose that upon hitting the default threshold debt claims are settled so b = 0.
% The restructured firm continues to operate but with capital, k = 0 and the previous
% productivity shock, z.

%%
% Note now the setting has changed a little bit from question c). 
% All we have to change is the value function continuation in the bellman
% equation, where we don't set value of default to zero. We set if to value
% when k and b are 0. Notice this is the only difference from c). 

%%
% 1) This period, if the firm % default, instead of setting the value to 0,
% I set it to value at k=0.0000001 and b=0, and policy function entry is 
% set to equal to the entry when k=0.0000001 and b=0.

%%
% 2) Next Period, if the firm % default, instead of setting the valueTomorrow
% to 0, I set it to value at k=0.0000001 and b=0.

%%
% I use two kinds of endogenous grids to solve the problem - (a-,a,k,b) and
% (a,n). For the first method, we can easily make both the first and second
% adjustment, but for the second method where we only have today's networth
% information, we can only make the second adjustment and assume that
% today's firms are nondefaulters and the 0 networth denotes defaulters.

% Use multigrid method to speed up iteration
kGridLength           = [15]; % number of points in grid for capital
Nk = max(kGridLength);
kMin            = 0.000001;
kMax            = 10 * kSteadyState;
grid_b = curvspace(0,kMax,Nb,2)';

% Required matrices and vectors
% Dimensionality is k,b,a,aMinus
kPolicyIndex = zeros(kGridLength(1),Nb,Na,Na);
kPolicy = zeros(kGridLength(1),Nb,Na,Na);
bPolicyIndex = zeros(kGridLength(1),Nb,Na,Na);
bPolicy = zeros(kGridLength(1),Nb,Na,Na);

value   = zeros(kGridLength(1),Nb,Na,Na);
value0 = ones(kGridLength(1),Nb,Na,Na); % initial guess

tic
for i=1:length(kGridLength)
    
    grid_k = curvspace(kMin,kMax,kGridLength(i),2)';
    
    % Calculate Default Probability
    mCutOffValue = zeros(kGridLength(i),Nb);
    mDefaultProbability = zeros(kGridLength(i),Nb,Na);
    vDenominator = grid_k.^aalphaK .* (aalphaL * grid_k.^aalphaK / W).^(aalphaL/(1-aalphaL)) - W * (aalphaL * grid_k.^aalphaK/W).^(1/(1-aalphaL));

    for ib = 1:Nb
        vNumerator =  (grid_b(ib) - (1-ddelta)*grid_k)/(1-ttaoC);
        vCutOffValue = vNumerator ./vDenominator;
        mCutOffValue(:,ib) = vCutOffValue; % cutoff value^(1-aalphaL) is cutoff productivity, but I don't use productivity per se in order to avoid complex numbers
        for ia = 1:Na
            for ik = 1:kGridLength(1)
                 temp= (vCutOffValue(ik) > grid_a.^(1/(1-aalphaL)));
                mDefaultProbability(ik,ib,ia) = sum(temp.* m_a_prob(ia,:)');
            end
        end
    end

    mRf = Rf*ones(kGridLength(1),Nb,Na);
    mCarryOnProbability = 1-mDefaultProbability;
    mIsDefaultNextPeriod = (mDefaultProbability==1);
    mRb = min(Rf/mCarryOnProbability,1000000);
        
    tolerance = 0.00001;
    iteration = 0;
    distance = 100;

    kPrime = repmat(grid_k,1,Nb); % Nk*Nb matrix
    bondPrime = repmat(grid_b',kGridLength(i),1); % Nk*Nb matrix

    tic
    while distance > tolerance
        for ia=1:Na
            a = grid_a(ia);
            isDefaultNextPeriod = mIsDefaultNextPeriod(:,:,ia);
            
            for ik=1:kGridLength(i)
                k = grid_k(ik);        
                profit = profitNkByNa(ik,ia);
                investment = investmentFunction(k,kPrime,isDefaultNextPeriod); % Nk*Nb matrix

                for iaMinus = 1:Na
                    RbMinus = mRb(:,:,iaMinus); % Nk*Nb matrix
                    aMinus = grid_a(iaMinus);

                    for ib = 1:Nb
                        bond = grid_b(ib);

                        if (1-ttaoC)*profit + (1-ddelta)*k <= bond
                            value (ik,ib,ia,iaMinus)=value0(1,1,ia,iaMinus);
                            
                            kPolicyIndex(ik,ib,ia,iaMinus) = kPolicyIndex(1,1,ia,iaMinus) ;
                            bPolicyIndex(ik,ib,ia,iaMinus) = bPolicyIndex(1,1,ia,iaMinus) ;

                            kPolicy(ik,ib,ia,iaMinus) = grid_k(kPolicyIndex(1,1,ia,iaMinus));
                            bPolicy(ik,ib,ia,iaMinus) = grid_b(bPolicyIndex(1,1,ia,iaMinus));

                        else

                            taxPayments = taxPaymentsFunction(k,bond,profit,RbMinus); % Nk*Nb matrix
                            divident = dividentFunction(profit,investment,bond,bondPrime,RbMinus,taxPayments,isDefaultNextPeriod); % Nk*Nb matrix

                            valueTomorrow = zeros(kGridLength(i),Nb,Na);% k',b',a'
                           
                            for iaPrime = 1:Na % iterate over all possible states for tomorrow
                                aPrime = grid_a(iaPrime);
                                profitPrime = repmat(profitNkByNa(:,iaPrime),1,Nb);% Nk*Nb
                                valueTomorrow(:,:,iaPrime) =  m_a_prob(ia,iaPrime) * (value0(:,:,iaPrime,ia).* ((1-ttaoC)*profitPrime + (1-ddelta)*kPrime > bondPrime)...
                                    +value0(1,1,iaPrime,ia).* ((1-ttaoC)*profitPrime + (1-ddelta)*kPrime <= bondPrime));% ÐèÒª¿¼ÂÇdefaultÖ®ºóvalue²»ÊÇÎª0£¬¶øÊÇÎªset bond and capital to 0µÄvalue
                            end
                            mExpectedValueTomorrow = sum(valueTomorrow,3); % sum by the third dimension to get a Nk*Nb matrix

                            x = divident + M * mExpectedValueTomorrow;

                            [rows,cols]=find(x==max(max(x)));
                            kPolicyIndex(ik,ib,ia,iaMinus) = min(rows);
                            bPolicyIndex(ik,ib,ia,iaMinus) = min(cols);

                            kPolicy(ik,ib,ia,iaMinus) = grid_k(min(rows));
                            bPolicy(ik,ib,ia,iaMinus) = grid_b(min(cols));
                            value(ik,ib,ia,iaMinus) = max(max(x));
                        end
                    end
                end
            end
        end

        distance = sum(sum(sum(sum(abs(value(:,:,:,:)-value0(:,:,:,:))))));
        value0 = value;
        iteration = iteration + 1;

        %if mod(iteration,5) == 0
        %    display("iteration =    " + iteration + "   difference =   " + distance )
        %end
    end

    display("iteration =    " + iteration + "   difference =   " + distance + ". Converged")
    if i ~= length(kGridLength)
        value0 = interp1(grid_k,value,linspace(kMin, kMax, kGridLength(i+1)));
        value  = value0;
        kPolicy         = zeros(kGridLength(i+1),Nb,Na,Na);
        kPolicyIndex    = zeros(kGridLength(i+1),Nb,Na,Na);
        bPolicy         = zeros(kGridLength(i+1),Nb,Na,Na);
        bPolicyIndex    = zeros(kGridLength(i+1),Nb,Na,Na);
        
    end
    
end

toc
save('resultD','value','kPolicy','bPolicy','kPolicyIndex','bPolicyIndex')

figure(6);
[bb,kk]=meshgrid(grid_b, grid_k);
mesh(bb, kk, value(:,:,1,round((Na+1)/2)));% yesterday's productivity is mean

for ia = 2:Na
    hold on;
    mesh(bb, kk, value(:,:,ia,round((Na+1)/2)));    
end

title('Value Under Different Shocks given mean $z^{-}$','interpreter','latex')
ylabel('Capital Stock $k$','interpreter','latex')
xlabel('Debt $b$','interpreter','latex')
zlabel('Value','interpreter','latex')
savefig('q1d_value_3D')

figure(7)
mesh(bb, kk, kPolicy(:,:,1,round((Na+1)/2)));% yesterday's productivity is mean

for ia = 2:Na
    hold on;
    mesh(bb, kk, kPolicy(:,:,ia,round((Na+1)/2)));    
end

title('Policy $k^\prime$ Under Different Shocks given mean $z^{-}$','interpreter','latex')
ylabel('Capital Stock $k$','interpreter','latex')
xlabel('Debt $b$','interpreter','latex')
zlabel('$k^\prime$','interpreter','latex')
savefig('q1d_kPolicy_3D')


figure(8)
mesh(bb, kk, bPolicy(:,:,1,round((Na+1)/2)));% yesterday's productivity is mean

for ia = 2:Na
    hold on;
    mesh(bb, kk, bPolicy(:,:,ia,round((Na+1)/2)));    
end

title('Policy $b^\prime$ Under Different Shocks given mean $z^{-}$','interpreter','latex')
ylabel('Capital Stock $k$','interpreter','latex')
xlabel('Debt $b$','interpreter','latex')
zlabel('$bond^\prime$','interpreter','latex')
savefig('q1d_bPolicy_3D')


%%
% Stationary Distribution
% Compute the stationary distribution of firms. 

distributionStationary0 = (1/(Nk*Nb*Na*Na))*ones(Nk,Nb,Na,Na);
distance=100;
tolerance=0.000001;
iteration=0;

while distance>tolerance
    distributionStationary1 = zeros(Nk,Nb,Na,Na);
    for ia=1:Na
        for iaMinus=1:Na
            for ib=1:Nb
                for ik=1:Nk
                    ikPrime = kPolicyIndex(ik,ib,ia,iaMinus);          
                    ibPrime = bPolicyIndex(ik,ib,ia,iaMinus);

                    prob = distributionStationary0(ik,ib,ia,iaMinus);
                    for iaPrime=1:Na
                        prob_aPrime = prob*m_a_prob(ia,iaPrime);
                        distributionStationary1(ikPrime,ibPrime,iaPrime,ia) = distributionStationary1(ikPrime,ibPrime,iaPrime,ia) + prob_aPrime;
                    end
                    
                end
            end
        end
    end
    
    distance=sum(sum(sum(sum(abs(distributionStationary0-distributionStationary1)))));
    distributionStationary0 = distributionStationary1;
    iteration = iteration + 1;
end

%%
% Plot the distribution
[bb,kk]=meshgrid(grid_b, grid_k);
aMinusDescription = ["low","medium","high"];

for iaMinus = 1:Na
    figure(8+iaMinus);
    mesh(bb, kk, distributionStationary0(:,:,1,iaMinus));
    
    for ia = 2:Na
        hold on;
        mesh(bb,kk,distributionStationary0(:,:,ia,iaMinus));
    end
    title(['Distribution $z^{-}$ ',aMinusDescription(iaMinus)],'interpreter','latex');
    ylabel('Capital Stock $k^\prime$','interpreter','latex')
    xlabel('Debt $b^\prime$','interpreter','latex')
    zlabel('Probability Mass','interpreter','latex')
end
    
savefig('q1d_stationary_distribution_3D')

%%
% Use the invariant distribution to construct
% a table reporting the cross-sectional average values of:

%%
% (1) probability of default, p();

%%
% (2) required return on risky bonds, Rb();

%%
% (3) leverage ratio, b/k;

%%
% (4) investment to capital ratio, i/k.

%%
% (5) fraction of firms issuing equity;

%%
% To solve this question, we create a 4-dimensional array in order to reduce the layer of loops.

mK4D=repmat(grid_k,1,Nb,Na,Na);% Nk*Nb*Na*Na matrix
mBond4D=repmat(grid_b',Nk,1,Na,Na); % Nk*Nb*Na*Na matrix

mA4D=repmat(grid_a',Na,1,Nb,Nk);
mA4D=permute(mA4D,[4,3,2,1]);% transform/reallocate the dimension to get a Nk*Nb*Na*Na matrix

mAMinus4D=repmat(grid_a,1,Na,Nb,Nk);
mAMinus4D=permute(mAMinus4D,[4,3,2,1]);% transform/reallocate the dimension to get a Nk*Nb*Na*Na matrix

%%
% (1) probability of default, p();
mProfit4D = profitFunction(mA4D,mK4D);% Nk*Nb matrix
mDefault4D = 1-nonDefaultFunction(mProfit4D,mK4D,mBond4D);% Nk*Nb 0-1 matrix
defaultProbability = sum(sum(sum(sum(mDefault4D.*distributionStationary0))));
fprintf('Average Default Probability is %2.10f\n', defaultProbability);
%%
% (2) required return on risky bonds, Rb();
riskyBondReturn = sum(sum(sum(sum((min(10000000000000,Rf/(1-mDefault4D))).*((mDefault4D~=1).*distributionStationary0)))));
fprintf('Required return on risky bonds on average is %2.8f\n', riskyBondReturn);
%%
%  As we can see, the result implies that corporate bonds are effectively riskfree.
%%
% (3) leverage ratio, b/k;
leverageRatio = sum(sum(sum(sum(mBond4D ./ mK4D   .*distributionStationary0))));
fprintf('Average leverage ratio is %2.8f\n', leverageRatio);
%%
% (4) investment to capital ratio, i/k.
investment2Capital=sum(sum(sum(sum((kPolicy./mK4D + 1 - ddelta).*distributionStationary0))));
fprintf('Average investment to capital ratio is %2.8f\n', investment2Capital);
%% 
% (5) fraction of firms issuing equity;
mIsDefaultNextPeriod4D = zeros(kGridLength(1),Nb,Na,Na);
for iaMinus=1:Na
    aMinus = grid_a(iaMinus);
    mIsDefaultNextPeriod4D(:,:,:,iaMinus)=mIsDefaultNextPeriod;
end

mRbMinus4D = zeros(kGridLength(1),Nb,Na,Na);
for ia = 1:Na
    a = grid_a(ia);
    for iaMinus = 1:Na
        aMinus = grid_a(iaMinus);
        mRbMinus4D(:,:,ia,iaMinus)=mRb(:,:,iaMinus);
    end
end
    
mInvestment4D = investmentFunction(mK4D,mK4D,mIsDefaultNextPeriod4D);
mTaxPayments4D = taxPaymentsFunction(mK4D,mBond4D,mProfit4D,mRbMinus4D);
mDivident4D = dividentFunction(mProfit4D,mInvestment4D,mBond4D,mBond4D,mRbMinus4D,mTaxPayments4D,mIsDefaultNextPeriod4D);

mIsIssuingEquity = (mDivident4D<0);
fractionOfFirmsIssuingEquity = sum(sum(sum(sum(  mIsIssuingEquity .*distributionStationary0))));
fprintf('The fraction of firms issuing equity is %2.8f\n', fractionOfFirmsIssuingEquity);

table(defaultProbability,riskyBondReturn,leverageRatio,investment2Capital,fractionOfFirmsIssuingEquity)


%% Part II: Method of Simulated Moments

% Housekeeping.
clear;
close all;

%%
% Parametization.

M = 0.99;
Rf = 1/M;
r = 1/M-1; % interest rate for notation convenience
ddelta = 0.1;
aalphaK = 0.3;
aalphaL = 0.6;
W = 2; % wage
llambda = 0.025; % proportional cost of issuing equity
ttaoC=0.15; % corporate tax rate

Nk = 20;
kMin = 0.00001;
kSteadyState = 1;
% a_grid and a's transition matrix
m = 3; % parameter for tauchen method
Na = 5;
ssigma = 0.05;
Nb = 15;
tolerance=0.00001;


%%
% We create a grid of rho and lambda.

kGridLength = [15]; % number of points in grid for capital
numsteps = 1000;

vOtherCoefs= [M ddelta aalphaK, aalphaL, W, ttaoC, Nk, kMin, kSteadyState];
vOtherCoefs= [vOtherCoefs m Na ssigma Nb tolerance]; %size 14

Vinit = ones(kGridLength(1),Nb,Na,Na); % initial guess


vRhos = [0.5 0.6 0.7 0.8 0.9];
vLambdas = [ 0.01 0.02 0.025 0.03 0.05];
numRhos = length(vRhos);
numLambdas = length(vLambdas);
numCoefs = 9; % rho, lambda, beta0-beta2, gamma0-gamma3
coefficients = zeros(numRhos*numLambdas,numCoefs);

ii = 0;
j = 0;
for rrho= vRhos
    ii = ii+1;
    coefficients(((ii-1)*numLambdas +1):(ii*numLambdas),1) = rrho;
    j = 0;
    for llambda = vLambdas
        j = j+1;
        coefficients((ii-1)*numLambdas+j,2) = llambda;
    end
end


%% 
% We now get the coefficients from code of 1.d) for each rho/lambda.

%%
% Here, we run the code from 1.d) with the different values of lambda and
% rho. 

%% 
% The function `funVectorCoefs` wraps the calculations of the value
% function and the steady state as in parts 1.c) and 1.d). Additionally, it
% runs a regression and saves the estimated parameters.

ii = 0;
j = 0;
for rrho= vRhos
    ii = ii+1;
    j = 0;
    for llambda = vLambdas
        j = j+1;
        [vectorCoefs, Vnew] = funVectorCoefs(rrho,llambda, Vinit,vOtherCoefs,...
            kGridLength,0, numsteps); %vectorCoefs = 1:7;
        Vinit = Vnew;
        coefficients((ii-1)*numLambdas+j,3:numCoefs) = vectorCoefs;
    end
end

%%
% We now find the optimal coefficients.

%once we have the coefficients, we just see which one is the closest one to the one given
betaObjective = [0.004 0.02 -0.15 -0.4 0.05]; %b1, b2, g1,g2,g3

%get rid of beta0 and gamma0
coefToCompare = coefficients(:,[4,5,7,8,9]);
errors = zeros(numRhos*numLambdas,1);

% find the best coefficients w.r.to the norm2 distance vs the given coefs.
errors(1) = norm(coefToCompare(1,:) - betaObjective,2);
minerror = errors(1);
minerrorii = 1;
for ii=2:(numRhos*numLambdas)
    errors(ii) = norm(coefToCompare(ii,:) - betaObjective,2);
    if errors(ii) < errors(ii-1)
        minerror = errors(ii);
        minerrorii = ii;
    end
end
display(['The best coefficients found are: rho = ', num2str(coefficients(minerrorii,1)), ' and lambda = ', num2str(coefficients(minerrorii,2))]);

%% Part III: Optimal Default
% First we need to decide on the default behavior - once default, will the
% firm continue to run the firm as the ownership with 0 capital and 0 bond 
% as in question 1(d), or will its ownership be changed and thus value put 
% to 0? 

%%
% It is implied in the Bellman equation that, once default, firms exit the
% market, since next period we are choosing between 0 and e(z',k',b'), not
% between e(z',0,0) and e(z',k',b').

%%
% Housekeeping

clear;
close all;

%%
% Parametization.

M = 0.99;
Rf = 1/M;
RbConstant = 1.01 * Rf;
r = 1/M-1; % risk free interest rate for notation convenience
ddelta = 0.1;
aalphaK = 0.3;
aalphaL = 0.6;
W = 2; % wage
llambda = 0.025; % proportional cost of issuing equity
ttaoC=0.15; % corporate tax rate

%% 
% a_grid, m_a_prob and a's transition probability matrix

kSteadyState = 1;
tempK = kSteadyState^((aalphaK+aalphaL-1)/(1-aalphaL));
aMean = ((r+ddelta)/aalphaK/tempK)^(1-aalphaL)*(W/aalphaL)^aalphaL; % set a such that k_SteadyState equals how much you set it to be;

% a_grid and a's transition matrix
m = 3; % parameter for tauchen method
Na = 3;
rrho = 0.7;
ssigma = 0.05;
[grid_a_log,m_a_prob] = tauchen(Na,log(aMean),rrho,ssigma,m);
grid_a = exp(grid_a_log)';
% grid_a_minus = grid_a;
aMax = max(grid_a);

% k_grid
kMax = (aMax/ddelta)^(1/(1-aalphaK));
kMax = min(2*kSteadyState, kMax); % Tighten the grid
% grid_k = curvspace(kMin,kMax,Nk,2)'; % I use curved grid to enhance accuracy

% b_grid grid for bond
% b_grid should be finer to see the difference in default probability under different productivity shocks at steady state
Nb = 20;
grid_b = curvspace(0,kMax,Nb,2)'; % To cover up as wide leverage level as possible

% invariant distribution of a_grid - vDistribution_a0
vDistribution_a0=( 1/Na )*ones(Na,1); % initial guess
vDistribution_a=vDistribution_a0;
distance=100; tolerance=0.00001;
iteration = 0;
while distance>tolerance
    distribution = vDistribution_a'*m_a_prob;
    distance=sum(abs(distribution-vDistribution_a'));
    vDistribution_a = distribution';
    iteration = iteration+1;
end

clear vDistribution_a0 distribution;

%%
% Create functions for convenience

profitFunction = @(a,k)a.* k.^aalphaK.* ((k.^aalphaK * aalphaL).* a/W).^(aalphaL/(1-aalphaL)) - W * ((k.^aalphaK * aalphaL).* a/W).^(1/(1-aalphaL));
investmentFunction = @(k,kPrime)kPrime - (1-ddelta)*k; %k_prime usually is k_grid
taxPaymentsFunction = @(k,bond,profit,RbMinus)ttaoC * (profit - ddelta*k - bond * (RbMinus-1)); % note the non-default indicator

dividentFunction = @(profit,investment,bond,bondPrime,RbMinus,taxPayments,mIsDefaultNextPeriod)(profit - investment  ...
    + bondPrime.*(1-mIsDefaultNextPeriod) - RbMinus.* bond - taxPayments).*(1 + llambda * ((profit - investment  ...
    + bondPrime.*(1-mIsDefaultNextPeriod) - RbMinus.* bond - taxPayments) < 0)); % note the indicator function for issuance cost

%% a) Value Function Iteration when Rb = 1.01Rf
% Solve the Bellman equation for equity.
% Plot the optimal investment and default decision for the equity holders.

%%
% State variables: k, b, z
% Control variables: k',b'

%%
% Considerations: 

%%
% a) whether to default this period (using value function<0 this period to decide); 

%%
% b) if next period regardless of a', value function is all less than 0, then b' can't be borrowed this much,
% and thus the firm had to fund the investment by equity.

% Use multigrid method to speed up iteration
kGridLength           = [20]; % number of points in grid for capital
Nk = max(kGridLength);
kMin            = 0.000001;
kMax            = 7 * kSteadyState;
bMax            = 7 * kSteadyState;
grid_b = curvspace(0,bMax,Nb,2)';

% Required matrices and vectors
% Dimensionality is k,b,a,aMinus
    
kPolicyIndex = zeros(kGridLength(1),Nb,Na);
kPolicy = zeros(kGridLength(1),Nb,Na);
bPolicyIndex = zeros(kGridLength(1),Nb,Na);
bPolicy = zeros(kGridLength(1),Nb,Na);

% Note default it not a % policy to make for the next period. default is a reaction in this period
% once productivity shock is realized and you see whether or not the value of the firm is larger than 0 or not.

mValue   = zeros(kGridLength(1),Nb,Na);
mValue0 = ones(kGridLength(1),Nb,Na); % initial guess

tic
for i=1:length(kGridLength)
    grid_k = curvspace(kMin,kMax,kGridLength(i),2)';
    % Since the profitFunction takes so much time, let's calculate it all
    % at once to retrieve later
    mANkByNa = repmat(grid_a',kGridLength(i),1);
    mKNkByNa = repmat(grid_k,1,Na);
    profitNkByNa = profitFunction(mANkByNa,mKNkByNa); % Nk by Na
    
    tolerance = 0.00001;
    iteration = 0;
    distance = 100;

    kPrimeNkByNb = repmat(grid_k,1,Nb); % Nk*Nb matrix
    bondPrimeNkByNb = repmat(grid_b',kGridLength(i),1); % Nk*Nb matrix
    
    tic
    while distance > tolerance
        mIsDefaultNextPeriod = zeros(kGridLength(i),Nb); % k' b' entry is 1 if it will default for sure next period
        for ibPrime = 1:Nb
            for ikPrime = 1:kGridLength(i)
                mIsDefaultNextPeriod(ikPrime,ibPrime) = (sum((mValue0(ikPrime,ibPrime,:)>=0)) == 0);
            end
        end
        
        for ia=1:Na
            a = grid_a(ia);

            for ik=1:kGridLength(i)
                k = grid_k(ik);        
                profit = profitNkByNa(ik,ia);% scalar
                investmentNkByNb = investmentFunction(k,kPrimeNkByNb); % Nk*Nb matrix

                for ib = 1:Nb
                    bond = grid_b(ib);
                    
                    if mValue0(ik,ib,ia) <0 % the firm will exit/default and choose no k' and b'
                        kPolicyIndex(ik,ib,ia) = 0;
                        kPolicy(ik,ib,ia) = 0;
                        bPolicyIndex(ik,ib,ia) = 0;
                        bPolicy(ik,ib,ia) = 0;
                    else % choose policy amongst k's b's
                        taxPayments = taxPaymentsFunction(k,bond,profit,RbConstant); % scalar
                        divident = dividentFunction(profit,investmentNkByNb,bond,bondPrimeNkByNb,RbConstant,taxPayments,mIsDefaultNextPeriod);% Nk*Nb matrix

                        % Next we shall calculate the expected value
                        % tomorrow. Note we have to apply Max operator
                        % first and then take expectations - which means
                        % only when we reach that period will the firm make
                        % the default/nondefault decision.
                        mValueTomorrow = zeros(kGridLength(i),Nb,Na); % k',b',a'                            
                        for iaPrime = 1:Na % iterate over all possible states for tomorrow
                            mValueTomorrow(:,:,iaPrime) = m_a_prob(ia,iaPrime) * ...
                                (max(0,mValue0(:,:,iaPrime)).*(1-mIsDefaultNextPeriod)...
                                + max(0,repmat(mValue0(:,1,iaPrime),1,Nb)).*mIsDefaultNextPeriod);
                            
                        end
                        mExpectedValueTomorrow = sum(mValueTomorrow,3); % sum by the third dimension to get a Nk*Nb matrix
                        
                        x = divident + M * mExpectedValueTomorrow;

                        [rows,cols]=find(x==max(max(x)));

                        kPolicyIndex(ik,ib,ia) = min(rows);
                        bPolicyIndex(ik,ib,ia) = min(cols);

                        kPolicy(ik,ib,ia) = grid_k(min(rows));
                        bPolicy(ik,ib,ia) = grid_b(min(cols));

                        mValue(ik,ib,ia) = max(max(x));

                    end
                end
            end
        end

        distance = sum(sum(sum(sum(abs(mValue(:,:,:,:)-mValue0(:,:,:,:))))));
        mValue0 = mValue;
        iteration = iteration + 1;

        %if mod(iteration,5) == 0
        %    display("iteration =    " + iteration + "   difference =   " + distance )
        %end
    end

    display("iteration =    " + iteration + "   difference =   " + distance + ". Converged")
    if i ~= length(kGridLength)
        mValue0 = interp1(grid_k, mValue,linspace(kMin, kMax, kGridLength(i+1))');% ÕâÀï²»ÖªµÀlinspaceºóÃæÒª²»Òª¼Ó'±äÎªÁÐÏòÁ¿¡£ÊÔÊÔ°É
        mValue  = mValue0;
        kPolicy         = zeros(kGridLength(i+1),Nb,Na);
        kPolicyIndex    = zeros(kGridLength(i+1),Nb,Na);
        bPolicy         = zeros(kGridLength(i+1),Nb,Na);
        bPolicyIndex    = zeros(kGridLength(i+1),Nb,Na);
    end
    
end

toc
save('resultA','mValue','kPolicy','bPolicy','kPolicyIndex','bPolicyIndex')

figure(1);
[bb,kk]=meshgrid(grid_b, grid_k);
mesh(bb, kk, mValue(:,:,1));% yesterday's productivity is mean

for ia = 2:Na
    hold on;
    mesh(bb, kk, mValue(:,:,ia));    
end

title('Value Under Different Shocks','interpreter','latex')
ylabel('Capital Stock $k$','interpreter','latex')
xlabel('Debt $b$','interpreter','latex')
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])

zlabel('Value','interpreter','latex')
savefig('q3a_value_3D')

%%

figure(2)
mesh(bb, kk, kPolicy(:,:,1));% yesterday's productivity is mean

for ia = 2:Na
    hold on;
    mesh(bb, kk, kPolicy(:,:,ia));    
end

title('Policy $k^\prime$ Under Different Shocks','interpreter','latex')
ylabel('Capital Stock $k$','interpreter','latex')
xlabel('Debt $b$','interpreter','latex')
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])

zlabel('$k^\prime$','interpreter','latex')
savefig('q3a_kPolicy_3D')

%%

figure(3)
mesh(bb, kk, bPolicy(:,:,1));% yesterday's productivity is mean

for ia = 2:Na
    hold on;
    mesh(bb, kk, bPolicy(:,:,ia));    
end

title('Policy $b^\prime$ Under Different Shocks','interpreter','latex')
ylabel('Capital Stock $k$','interpreter','latex')
xlabel('Debt $b$','interpreter','latex')
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])

zlabel('$bond^\prime$','interpreter','latex')
savefig('q3a_bPolicy_3D')

%% 
% We plot the optimal investment and default decision for the equity holders.

mK3D=repmat(grid_k,1,Nb,Na);% Nk*Nb*Na matrix
investmentPolicy = kPolicy - (1-ddelta) * mK3D;

figure(4)
mesh(bb, kk, investmentPolicy(:,:,1));% yesterday's productivity is mean

for ia = 2:Na
    hold on;
    mesh(bb, kk, investmentPolicy(:,:,ia));    
end

title('Policy $investment^\prime$ Under Different Shocks','interpreter','latex')
ylabel('Capital Stock $k$','interpreter','latex')
xlabel('Debt $b$','interpreter','latex')
zlabel('$investment^\prime$','interpreter','latex')
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])

savefig('q3a_investmentPolicy_3D')

%%

figure(5)
mIsDefaultToday = (mValue<0);
mesh(bb, kk, mIsDefaultToday(:,:,1));% yesterday's productivity is mean

for ia = 2:Na
    hold on;
    mesh(bb, kk, mIsDefaultToday(:,:,ia));    
end

title('Whether to Default Today Under Different Shocks','interpreter','latex')
ylabel('Capital Stock $k$','interpreter','latex')
xlabel('Debt $b$','interpreter','latex')
zlabel('default','interpreter','latex')
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])

savefig('q3a_IsDefaultToday_3D')

%%
% Compute the stationary distribution to see how good is the range of the
% grid

distributionStationary0 = (1/(Nk*Nb*Na))*ones(Nk,Nb,Na);
distance=100;
tolerance=0.0000000001;
iteration=0;

while distance>tolerance
    distributionStationary1 = zeros(Nk,Nb,Na);
    for ia=1:Na
        for ib=1:Nb
            for ik=1:Nk
                ikPrime = max(1,kPolicyIndex(ik,ib,ia));          
                ibPrime = max(1,bPolicyIndex(ik,ib,ia)); 

                prob = distributionStationary0(ik,ib,ia);
                for iaPrime=1:Na
                    prob_aPrime = prob*m_a_prob(ia,iaPrime);
                    distributionStationary1(ikPrime,ibPrime,iaPrime) = distributionStationary1(ikPrime,ibPrime,iaPrime) + prob_aPrime;
                end
                    
                
            end
        end
    end
    
    distance=sum(sum(sum(abs(distributionStationary0-distributionStationary1))));
    distributionStationary0 = distributionStationary1;
    iteration = iteration + 1;
end

%%
% We finally plot the distribution.

figure(6);
[bb,kk]=meshgrid(grid_b, grid_k);
mesh(bb, kk, distributionStationary0(:,:,1));
for ia = 2:Na
    hold on
    mesh(bb, kk, distributionStationary0(:,:,ia));
end

title('Stationary Distribution','interpreter','latex');
ylabel('Capital Stock $k$','interpreter','latex')
xlabel('Debt $b$','interpreter','latex')
zlabel('Probability Mass','interpreter','latex')
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])

savefig('q3a_stationary_distribution_3D')



%% b) Probability of Default Next Period
% We compute and plot the probability of default next period, 
% conditional on the value of the shocks today p(z; b'; k')

mDefaultProbability = zeros(Nk,Nb,Na);% k',b',a
for ibPrime = 1:Nb
    for ikPrime = 1:Nk
        for ia = 1:Na
            mDefaultProbability(ikPrime,ibPrime,ia) = sum(reshape((mValue(ikPrime,ibPrime,:)<0),1,Na).*m_a_prob(ia,:));
        end
    end
end

figure(7)
mesh(bb, kk, mDefaultProbability(:,:,1));

for ia = 2:Na
    hold on;
    mesh(bb, kk, mDefaultProbability(:,:,ia));    
end

title('Next Period Default Probability')
ylabel('Next Period Capital Stock $k^\prime$','interpreter','latex')
xlabel('Next Period Debt $b^\prime$','interpreter','latex')
zlabel('Next Period Default Probability','interpreter','latex')
zlim([0,1])
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])

savefig('q3b_default_prob_3D')

%% c) Required Rate of Return of Bonds
% We now use the conditional default probability to compute the required rate of return
% by bondholders, Rb(b'; k'; z) that ensures they make 0 profits. We assume that
% bondholders get paid 0 upon default.

mRf = Rf*ones(Nk,Nb,Na);
mCarryOnProbability = 1-mDefaultProbability;
mIsDefaultNextPeriod3D = (mDefaultProbability==1); % (b'; k'; z)
mRb = Rf/mCarryOnProbability;

%% d) Value Function Iteration given Rb = mRb(k',b',z).
% We solve the Bellman equation for the equity holders taking as given this new function
% for the required rate of return by bondholders, Rb().

%%
% Now we have to keep track of a-.

%%
% State variables: k,b,a,a-

%%
% Control variables: k',b'

% Required matrices and vectors
% Dimensionality is k,b,a,aMinus
    
kPolicyIndex = zeros(kGridLength(1),Nb,Na,Na);
kPolicy = zeros(kGridLength(1),Nb,Na,Na);
bPolicyIndex = zeros(kGridLength(1),Nb,Na,Na);
bPolicy = zeros(kGridLength(1),Nb,Na,Na);
% Note default it not a % policy to make for the next period. default is a reaction in this period
% once productivity shock is realized and you see whether or not the value of the firm is larger than 0 or not.

mValue   = zeros(kGridLength(1),Nb,Na,Na);
mValue0 = ones(kGridLength(1),Nb,Na,Na); % initial guess


tic
for i=1:length(kGridLength)
    grid_k = curvspace(kMin,kMax,kGridLength(i),2)';
    % Since the profitFunction takes so much time, let's calculate it all
    % at once to retrieve later
    mANkByNa = repmat(grid_a',kGridLength(i),1);
    mKNkByNa = repmat(grid_k,1,Na);
    profitNkByNa = profitFunction(mANkByNa,mKNkByNa); % Nk by Na
    
    tolerance = 0.00001;
    iteration = 0;
    distance = 100;

    kPrimeNkByNb = repmat(grid_k,1,Nb); % Nk*Nb matrix
    bondPrimeNkByNb = repmat(grid_b',kGridLength(i),1); % Nk*Nb matrix
    
    tic
    while distance > tolerance
        % mIsDefaultNextPeriod is already computed.
        
        for ia=1:Na
            a = grid_a(ia);
            mIsDefaultNextPeriod2D = mIsDefaultNextPeriod3D(:,:,ia); % Nk*Nb matrix

            for ik=1:kGridLength(i)
                k = grid_k(ik);        
                profit = profitNkByNa(ik,ia);% scalar
                investmentNkByNb = investmentFunction(k,kPrimeNkByNb); % Nk*Nb matrix

                for ib = 1:Nb
                    bond = grid_b(ib);
                    
                    for iaMinus = 1:Na
                        RbMinus = mRb(ik,ib,iaMinus); % scalar
                    
                        if mValue0(ik,ib,ia,iaMinus) <0 % the firm will exit/default and choose no k' and b'
                            kPolicyIndex(ik,ib,ia,iaMinus) = 0;
                            kPolicy(ik,ib,ia,iaMinus) = 0;
                            bPolicyIndex(ik,ib,ia,iaMinus) = 0;
                            bPolicy(ik,ib,ia,iaMinus) = 0;
                        else % choose policy amongst k's b's
                            taxPayments = taxPaymentsFunction(k,bond,profit,RbMinus); % scalar
                            divident = dividentFunction(profit,investmentNkByNb,bond,bondPrimeNkByNb,RbMinus,taxPayments,mIsDefaultNextPeriod2D);% Nk*Nb matrix
                            
                            % Next we shall calculate the expected value
                            % tomorrow. Note we have to apply Max operator
                            % first and then take expectations - which means
                            % only when we reach that period will the firm make
                            % the default/nondefault decision.
                            mValueTomorrow = zeros(kGridLength(i),Nb,Na); % k',b',a'                            
                            for iaPrime = 1:Na % iterate over all possible states for tomorrow
                                mValueTomorrow(:,:,iaPrime) = m_a_prob(ia,iaPrime) * ...
                                    (max(0,mValue0(:,:,iaPrime)).*(1-mIsDefaultNextPeriod2D)...
                                    + max(0,repmat(mValue0(:,1,iaPrime),1,Nb)).*mIsDefaultNextPeriod2D);
                            
                            end
                            mExpectedValueTomorrow = sum(mValueTomorrow,3); % sum by the third dimension to get a Nk*Nb matrix

                            x = divident + M * mExpectedValueTomorrow;

                            [rows,cols]=find(x==max(max(x)));

                            kPolicyIndex(ik,ib,ia,iaMinus) = min(rows);
                            bPolicyIndex(ik,ib,ia,iaMinus) = min(cols);

                            kPolicy(ik,ib,ia,iaMinus) = grid_k(min(rows));
                            bPolicy(ik,ib,ia,iaMinus) = grid_b(min(cols));

                            mValue(ik,ib,ia,iaMinus) = max(max(x));

                        end
                    end
                end
            end
        end

        distance = sum(sum(sum(sum(abs(mValue(:,:,:,:)-mValue0(:,:,:,:))))));
        mValue0 = mValue;
        iteration = iteration + 1;

        %if mod(iteration,5) == 0
        %    display("iteration =    " + iteration + "   difference =   " + distance )
        %end
    end

    display("iteration =    " + iteration + "   difference =   " + distance + ". Converged")
    if i ~= length(kGridLength)
        mValue0 = interp1(grid_k, mValue,linspace(kMin, kMax, kGridLength(i+1))');
        mValue  = mValue0;
        kPolicy         = zeros(kGridLength(i+1),Nb,Na,Na);
        kPolicyIndex    = zeros(kGridLength(i+1),Nb,Na,Na);
        bPolicy         = zeros(kGridLength(i+1),Nb,Na,Na);
        bPolicyIndex    = zeros(kGridLength(i+1),Nb,Na,Na);
    end
    
end

toc
save('resultD','mValue','kPolicy','bPolicy','kPolicyIndex','bPolicyIndex')

%%

figure(8);
[bb,kk]=meshgrid(grid_b, grid_k);
mesh(bb, kk, mValue(:,:,1,round((Na+1)/2)));% yesterday's productivity is mean

for ia = 2:Na
    hold on;
    mesh(bb, kk, mValue(:,:,ia,round((Na+1)/2)));    
end

title('Value Under Different Shocks given mean $z^{-}$','interpreter','latex')
ylabel('Capital Stock $k$','interpreter','latex')
xlabel('Debt $b$','interpreter','latex')
zlabel('Value','interpreter','latex')
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])

zlim([-max(max(max(max(mValue)))),max(max(max(max(mValue))))])
% legend('low productivity','median productivity','high productivity') % no use in mesh
savefig('q3d_value_3D')

%%

figure(9)
mesh(bb, kk, kPolicy(:,:,1,round((Na+1)/2)));% yesterday's productivity is mean

for ia = 2:Na
    hold on;
    mesh(bb, kk, kPolicy(:,:,ia,round((Na+1)/2)));    
end

title('Policy $k^\prime$ Under Different Shocks given mean $z^{-}$','interpreter','latex')
ylabel('Capital Stock $k$','interpreter','latex')
xlabel('Debt $b$','interpreter','latex')
zlabel('$k^\prime$','interpreter','latex')
% legend('low productivity','median productivity','high productivity') % no use in mesh
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])

savefig('q3d_kPolicy_3D')

%%

figure(10)
mesh(bb, kk, bPolicy(:,:,1,round((Na+1)/2)));% yesterday's productivity is mean

for ia = 2:Na
    hold on;
    mesh(bb, kk, bPolicy(:,:,ia,round((Na+1)/2)));    
end

title('Policy $b^\prime$ Under Different Shocks given mean $z^{-}$','interpreter','latex')
ylabel('Capital Stock $k$','interpreter','latex')
xlabel('Debt $b$','interpreter','latex')
zlabel('$bond^\prime$','interpreter','latex')
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])
savefig('q3d_bPolicy_3D')

%%
% Compute the stationary distribution to see how good is the range of the
% grid

distributionStationary0 = (1/(Nk*Nb*Na*Na))*ones(Nk,Nb,Na,Na);
distance=100;
tolerance=0.0000000001;
iteration=0;

while distance>tolerance
    distributionStationary1 = zeros(Nk,Nb,Na,Na);
    for ia=1:Na
        for iaMinus=1:Na
            for ib=1:Nb
                for ik=1:Nk
                    ikPrime = max(1,kPolicyIndex(ik,ib,ia,iaMinus));          
                    ibPrime = max(1,bPolicyIndex(ik,ib,ia,iaMinus)); 

                    prob = distributionStationary0(ik,ib,ia,iaMinus);
                    for iaPrime=1:Na
                        prob_aPrime = prob*m_a_prob(ia,iaPrime);
                        distributionStationary1(ikPrime,ibPrime,iaPrime,ia) = distributionStationary1(ikPrime,ibPrime,iaPrime,ia) + prob_aPrime;
                    end
                    
                end
            end
        end
    end
    
    distance=sum(sum(sum(sum(abs(distributionStationary0-distributionStationary1)))));
    distributionStationary0 = distributionStationary1;
    iteration = iteration + 1;
end

%%
% Plot the distribution.

figure(11);
[bb,kk]=meshgrid(grid_b, grid_k);
mesh(bb, kk, distributionStationary0(:,:,1,1));
for iaMinus = 2:Na
    for ia = 2:Na
        hold on
        mesh(bb, kk, distributionStationary0(:,:,ia,iaMinus));
    end
end
title('Stationary Distribution','interpreter','latex');
ylabel('Capital Stock $k$','interpreter','latex')
xlabel('Debt $b$','interpreter','latex')
zlabel('Probability Mass','interpreter','latex')
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])

savefig('q3d_stationary_distribution_3D')

%%
% Plot this new value function against the one found in section a).

figure(12);
[bb,kk]=meshgrid(grid_b, grid_k);

load('resultA.mat')
mesh(bb, kk, mValue(:,:,1));

for ia = 2:Na
    hold on;
    mesh(bb, kk, mValue(:,:,ia));    
end
title('Value Functions a)','interpreter','latex')
ylabel('Capital Stock $k$','interpreter','latex')
xlabel('Debt $b$','interpreter','latex')
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])
zlim([-max(max(max(max(mValue)))),max(max(max(max(mValue))))])
zlabel('Value','interpreter','latex')
savefig('q3d_value_3D_resultA_and_resultD1')

figure(13);
load('resultD.mat')
mesh(bb, kk, mValue(:,:,1));
for ia = 2:Na
    hold on;
    mesh(bb, kk, mValue(:,:,ia));    
end
title('Value Functions d)','interpreter','latex')
ylabel('Capital Stock $k$','interpreter','latex')
xlabel('Debt $b$','interpreter','latex')
ylim([min(grid_k),max(grid_k)])
xlim([min(grid_b),max(grid_b)])
zlim([-max(max(max(max(mValue)))),max(max(max(max(mValue))))])
zlabel('Value','interpreter','latex')
savefig('q3d_value_3D_resultA_and_resultD2')

%%
% As we can see from the picture, the difference is only at the region where capital is extremely low and bond is extremely high.

%%
% This makes sense, because in a model where interest rate on risky bond
% does not depend on the default risk but is exogenously given, there will
% hardly be negative values because you won't pay very high interest rate
% even though your default probability is almost 1, or exactly one. That
% case, if you don't default, you just pay a relatively low interest rate 
% and if you default because the value would be negative if you didn't, 
% the supposed negative value cannot be too negative because the interest 
% rate is just 1.01 times the riskfree rate.

%%
% On the other hand, in a model where interest rate on risky bond does
% depend on the default risk, once you ask for a very risky debt, the
% interest rate is so high that once there is a low productivity shock next
% period, you are more willing to default because if you chose not to, the
% value would be very very negative because you would have to pay a super
% high interest rate for the high risk debt you asked for last period.
##### SOURCE END #####
--></body></html>